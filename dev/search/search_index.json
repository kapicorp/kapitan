{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kapitan: Keep your ship together","text":"<p>Kapitan aims to be your one-stop configuration management solution to help you manage the ever growing complexity of your configurations by enabling Platform Engineering and GitOps workflows. </p> <p>It streamlines complex deployments across heterogeneous environments while providing a secure and adaptable framework for managing infrastructure configurations.  Kapitan's inventory-driven model, powerful templating capabilities, and native secret management tools offer granular control, fostering consistency, reducing errors, and safeguarding sensitive data.</p> <p>Empower your team to make changes to your infrastructure whilst maintaining full control, with a GitOps approach and full transparency.</p> <ul> <li> Join the community <code>#kapitan</code></li> <li> Help us grow: give us a star or even better sponsor our project</li> </ul>"},{"location":"#why-do-i-need-kapitan","title":"Why do I need Kapitan?","text":""},{"location":"#video-tutorials-to-get-started","title":"Video Tutorials to get started","text":"<p>Kapitan Youtube Channel</p> InventoryReferencesHelm and Generators integrationRawkode: Introduction to Kapitan <p></p> <p></p> <p></p> <p></p>"},{"location":"ADOPTERS/","title":"Who uses Kapitan","text":"<p>If you're using Kapitan in your organization, please let us know by adding to this list on the docs/ADOPTERS.md file.</p>"},{"location":"FAQ/","title":"FAQ","text":""},{"location":"FAQ/#why-do-i-need-kapitan","title":"Why do I need Kapitan?","text":"<p>See Why do I need Kapitan?</p>"},{"location":"FAQ/#ask-your-question","title":"Ask your question","text":"<p>Please use the comments facility below to ask your question</p>"},{"location":"getting_started/","title":"Kapitan Overview","text":""},{"location":"getting_started/#setup-your-installation","title":"Setup your installation","text":"<p>Using our reference repositories you can easily get started with Kapitan</p>"},{"location":"getting_started/#examples-repository","title":"Examples repository","text":"<p>kapicorp/kapitan-reference repository is meant show you many working examples of things you can do with Kapitan. You can use this to get familiar with Kapitan</p> <pre><code>$ git clone git@github.com:kapicorp/kapitan-reference.git kapitan-templates\n$ cd kapitan-templates\n\n$ ./kapitan compile\nCompiled postgres-proxy (1.51s)\nCompiled tesoro (1.70s)\nCompiled echo-server (1.64s)\nCompiled mysql (1.67s)\nCompiled gke-pvm-killer (1.17s)\nCompiled prod-sockshop (4.74s)\nCompiled dev-sockshop (4.74s)\nCompiled tutorial (1.68s)\nCompiled global (0.76s)\nCompiled examples (2.60s)\nCompiled pritunl (2.03s)\nCompiled sock-shop (4.36s)\n</code></pre>"},{"location":"getting_started/#minimal-repository","title":"Minimal repository","text":"<p>Using cruft based cookiecutter</p> <pre><code>pip3 install cruft\n</code></pre> <pre><code>cruft create http://github.com/kapicorp/kapitan-reference --checkout cookiecutter --no-input\nDependency https://github.com/kapicorp/generators.git: saved to system/lib\nDependency https://github.com/kapicorp/generators.git: saved to system/generators/kubernetes\nDependency https://github.com/kapicorp/generators.git: saved to system/generators/terraform\nRendered inventory (1.74s)\nCompiled echo-server (0.14s)\n</code></pre>"},{"location":"getting_started/#running-kapitan","title":"running Kapitan","text":"<p>recommended</p>"},{"location":"getting_started/#kapitan-wrapper-script","title":"<code>kapitan</code> wrapper script","text":"<p>If you use the provided repository, we already package a <code>kapitan</code> shell script that wraps the docker command to run Kapitan</p> <pre><code>$ ./kapitan compile\nCompiled postgres-proxy (1.51s)\nCompiled tesoro (1.70s)\nCompiled echo-server (1.64s)\nCompiled mysql (1.67s)\nCompiled gke-pvm-killer (1.17s)\nCompiled prod-sockshop (4.74s)\nCompiled dev-sockshop (4.74s)\nCompiled tutorial (1.68s)\nCompiled global (0.76s)\nCompiled examples (2.60s)\nCompiled pritunl (2.03s)\nCompiled sock-shop (4.36s)\n</code></pre>"},{"location":"getting_started/#other-installation-methods","title":"Other installation methods","text":""},{"location":"getting_started/#docker","title":"Docker","text":"<p>recommended</p>"},{"location":"getting_started/#docker_1","title":"Docker","text":"LinuxMac <pre><code>alias kapitan=\"docker run -t --rm -u $(id -u) -v $(pwd):/src:delegated kapicorp/kapitan\"\nkapitan -h\n</code></pre> <pre><code>alias kapitan=\"docker run -t --rm -v $(pwd):/src:delegated kapicorp/kapitan\"\nkapitan -h\n</code></pre>"},{"location":"getting_started/#pip","title":"Pip","text":""},{"location":"getting_started/#install-python","title":"Install Python","text":"LinuxMac <pre><code>sudo apt-get update &amp;&amp; sudo apt-get install -y python3.8-dev python3-pip python3-yaml\n</code></pre> <pre><code>brew install python3 libyaml libmagic\n</code></pre>"},{"location":"getting_started/#install-kapitan-using-pip","title":"Install Kapitan using pip","text":""},{"location":"getting_started/#user","title":"User","text":"LinuxMac <p><code>kapitan</code> will be installed in <code>$HOME/.local/lib/python3.7/bin</code></p> <pre><code>pip3 install --user --upgrade kapitan\n</code></pre> <p><code>kapitan</code> will be installed in <code>$HOME/Library/Python/3.7/bin</code></p> <pre><code>pip3 install --user --upgrade kapitan\n</code></pre>"},{"location":"getting_started/#system-wide","title":"System-wide","text":"<p>not recommended</p> <pre><code>sudo pip3 install --upgrade kapitan\n</code></pre>"},{"location":"proposals/","title":"Kapitan proposals","text":"","tags":["community"]},{"location":"proposals/#introduction","title":"Introduction","text":"<p>Proposals can be submitted for review by performing a pull request against this repository. If approved the proposal will be published here for further review by the Kapitan community. Proposals tend to be improvements or design consideration for new features.</p>","tags":["community"]},{"location":"proposals/#existing-proposals","title":"Existing proposals","text":"<p>Kadet input type</p> <p>External dependency management</p> <p>Helm charts input type</p> <p>Kubernetes scheme validation</p> <p>Portable standalone Kapitan executable</p> <p>Ref types redesign</p> <p>Hashicorp vault secrets</p>","tags":["community"]},{"location":"references/","title":"Kapitan References (formally Secrets)","text":"<p>One of the motivations behing Kapitan's design is that we believe that everything about your setup should be tracked, and Kapitan takes this to the extreme. Sometimes, however, we have to manage values that we do not think they belong to the Inventory: perhaps they are either too variable (for instance, a Git commit sha that changes with every build) or too sensitive, like a password or a generic secret, and then they should always be encrypted.</p> <p>Kapitan has a built in support for References, which you can use to manage both these use cases.</p> <p>Kapitan References supports the following backends:</p> Backend Description Encrypted <code>plain</code> Plain text, (e.g. commit sha) <code>base64</code> Base64, non confidential but with base64 encoding <code>gpg</code> Support for https://gnupg.org/ <code>gkms</code> GCP KMS <code>awskms</code> AWS KMS <code>azkms</code> Azure Key Vault <code>env</code> Environment <code>vaultkv</code> Hashicorp Vault (RO) <code>vaulttransit</code> Hashicorp Vault (encrypt, decrypt, update_key, rotate_key)"},{"location":"references/#setup","title":"Setup","text":"<p>Some reference backends require configuration, both in the Inventory and to configure the actual backend.</p> <p>Get started</p> <p>If you want to get started with references but don't want to deal with the initial setup, you can use the <code>plain</code> and <code>base64</code> reference types. These are great for demos, but we will see they are extremely helpful even in Production environments.</p> <p>Danger</p> <p>Both <code>plain</code> and <code>base64</code> references do not support encryption: they are intended for development or demo purposes only. DO NOT use <code>plain</code> or <code>base64</code> for storing sensitive information!</p> <p>Backend configuration</p> <p>Configuration for each backend varies, and it is perfomed by configuring the inventory under <code>parameters.kapitan.secrets</code>.</p> plainbase64gpggkmsawskmsazkmsenvvaultkvvaulttransit <p>No configuration needed</p> <p>No configuration needed</p> <pre><code>parameters:\n  kapitan:\n    secrets:\n      gpg:\n        recipients:\n          - name: example@kapitan.dev\n            fingerprint: D9234C61F58BEB3ED8552A57E28DC07A3CBFAE7C\n</code></pre> <pre><code>parameters:\n  kapitan:\n    secrets:\n      gkms:\n        key: 'projects/&lt;project&gt;/locations/&lt;location&gt;/keyRings/&lt;keyRing&gt;/cryptoKeys/&lt;key&gt;'\n</code></pre> <pre><code>parameters:\n  kapitan:\n    secrets:\n      awskms:\n        key: 'alias/nameOfKey'\n</code></pre> <pre><code>parameters:\n  kapitan:\n    secrets:\n      azkms:\n        key: 'https://&lt;keyvault-name&gt;.vault.azure.net/keys/&lt;object-name&gt;/&lt;object-version&gt;'\n</code></pre> <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{env:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre> <pre><code>parameters:\n  kapitan:\n    secrets:\n      vaultkv:\n        VAULT_ADDR: http://127.0.0.1:8200\n        auth: token\n        mount: secret\n</code></pre> <pre><code>parameters:\n  kapitan:\n    secrets:\n      vaulttransit:\n        VAULT_ADDR: https://vault.example.com\n        VAULT_TOKEN: s.mqWkI0uB6So0aHH0v0jyDs97\n        VAULT_SKIP_VERIFY: \"False\"  # Recommended\n        auth: token\n        mount: mytransit\n        key: 2022-02-13-test\n</code></pre> <p>Organize your configuration in classes</p> <p>Just like any other inventory parameters, these configurations can be inherited from a common class or defined per target.</p> <p><code>inventory/classes/common.yml</code></p> <pre><code>classes:\n- security.backend\n...\n</code></pre> <p><code>inventory/classes/security/backend.yml</code></p> <pre><code>parameters:\n  kapitan:\n    secrets:\n      &lt;backend&gt;: &lt;configuration&gt;\n</code></pre> ADVANCED: Mix-and-Match backends <p>Remember that you can use multiple backends at the same time, and also use variable interpolation for an even greater flexibility. </p> <p>In a multi-cloud setup, for instance, you could configure both GKMS</p> <p>GCP configuration</p> <p><code>inventory/classes/cloud/gcp.yml</code></p> <pre><code>classes:\n- security.backends.gkms\n...\n</code></pre> <p><code>inventory/classes/security/backends/gkms.yml</code></p> <pre><code># Configuration for GCP targets\nparameters:\n  backend: gkms\n  kapitan:\n    secrets:\n      gkms: &lt;configuration&gt;\n</code></pre> <p>AWS configuration</p> <p><code>inventory/classes/security/backends/awskms.yml</code></p> <pre><code># Configuration for AWS targets\nparameters:\n  backend: awskms\n  kapitan:\n    secrets:\n      awskms: &lt;configuration&gt;\n</code></pre> <p><code>inventory/classes/cloud/aws.yml</code></p> <pre><code>classes:\n- security.backends.awskms\n...\n</code></pre> <p>Now because they both set the <code>parameters.backend</code> variable, you can define a reference whose backend changes based on what class is assigned to the target</p> <p><code>inventory/targets/cloud/gcp/acme.yml</code></p> <pre><code>classes:\n- cloud.aws\n\nparameters:\n  ...\n  mysql:\n    # the secret backend will change based on the cloud assigned to this target\n    root_password: ?{${backend}:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre>"},{"location":"references/#define-references","title":"Define references","text":"<p>References can be defined in the inventory following the syntax spaces added for clarity:</p> <p><code>?{</code> <code>&lt;backend_id&gt;</code> <code>:</code> <code>&lt;reference_path&gt;</code> <code>}</code></p> expand for advanced features <p>The syntax also supports for process functions and create_functions which we will discuss later, which brings the full syntax to </p> <p><code>?{</code> <code>&lt;backend_id&gt;</code> <code>:</code> <code>&lt;reference_path&gt;</code> <code>}</code> |<code>&lt;process_function&gt;</code> ||<code>&lt;create_function&gt;</code></p> plainbase64gpggkmsawskmsazkmsenvvaultkvvaulttransit <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{plain:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre> <p>not encrypted</p> <p>This reference type does not support encryption: it is intended for non sensitive data only. DO NOT use <code>plain</code> for storing sensitive information!</p> <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{base64:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre> <p>not encrypted</p> <p>This reference type does not support encryption: it is intended for non sensitive data only. DO NOT use <code>base64</code> for storing sensitive information!</p> <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{gpg:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre> <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{gkms:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre> <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{awskms:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre> <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{azkms:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre> <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{env:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre> <p>read-only <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{vaultkv:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre> read-write: <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{vaultkv:targets/${target_name}/mysql/root_password:mount:path/in/vault:mykey}\n  ...\n</code></pre></p> <pre><code>parameters:\n  ...\n  mysql:\n    root_password: ?{vaulttransit:targets/${target_name}/mysql/root_password}\n  ...\n</code></pre>"},{"location":"references/#assign-a-value","title":"Assign a value","text":""},{"location":"references/#manually","title":"Manually","text":"<p>You can assign values to your reference using the command line. Both reading from a file and pipes are supported.</p> <p>Please Note</p> <p>Kapitan will fail compilation if a reference is not found. Please see how to assign a value automatically in the next section</p> plainbase64gpggkmsawskmsazkmsenvvaultkvvaulttransit <pre><code>kapitan refs --write plain:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f &lt;input file&gt;\n</code></pre> <p>which also works with pipes</p> <pre><code>cat input_file | kapitan refs --write plain:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f -\n</code></pre> <pre><code>kapitan refs --write base64:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f &lt;input file&gt;\n</code></pre> <p>which also works with pipes</p> <pre><code>cat input_file | kapitan refs --write base64:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f -\n</code></pre> <pre><code>kapitan refs --write gpg:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f &lt;input file&gt;\n</code></pre> <p>which also works with pipes</p> <pre><code>cat input_file | kapitan refs --write gpg:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f -\n</code></pre> <pre><code>kapitan refs --write gkms:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f &lt;input file&gt;\n</code></pre> <p>which also works with pipes</p> <pre><code>cat input_file | kapitan refs --write gkms:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f -\n</code></pre> <pre><code>kapitan refs --write vaulttransit:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f &lt;input file&gt;\n</code></pre> <p>which also works with pipes</p> <pre><code>cat input_file | kapitan refs --write vaulttransit:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f -\n</code></pre> <pre><code>kapitan refs --write azkms:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f &lt;input file&gt;\n</code></pre> <p>which also works with pipes</p> <pre><code>cat input_file | kapitan refs --write azkms:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f -\n</code></pre> <p>Setting default value only</p> <p>The <code>env</code> backend works in a slightly different ways, as it allows you to reference environment variables at runtime.</p> <p>For example, for a reference called <code>{?env:targets/envs_defaults/mysql_port_${target_name}}</code>, Kapitan would look for an environment variable called <code>KAPITAN_ENV_mysql_port_${TARGET_NAME}</code>. </p> <p>If that variable cannot be found in the Kapitan environment, the default will be taken from the <code>refs/targets/envs_defaults/mysql_port_${TARGET_NAME}</code> file instead.</p> <pre><code>kapitan refs --write env:refs/targets/envs_defaults/mysql_port_${TARGET_NAME} -t ${TARGET_NAME} -f &lt;input file&gt;\n</code></pre> <p>which also works with pipes</p> <pre><code>cat input_file | kapitan refs --write env:refs/targets/envs_defaults/mysql_port_${TARGET_NAME} -t ${TARGET_NAME} -f -\n</code></pre> <pre><code>kapitan refs --write vaultkv:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f &lt;input file&gt;\n</code></pre> <p>which also works with pipes</p> <pre><code>cat input_file | kapitan refs --write vaultkv:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f -\n</code></pre> <p>This backend expects the value to be stored as a <code>key:value</code> pair. </p> <pre><code>echo \"a_key:a_value\" | kapitan refs --write vaulttransit:refs/targets/${TARGET_NAME}/mysql/root_password -t ${TARGET_NAME} -f -\n</code></pre> <p>When reading from disk, the input file should be formatted accordingly.</p>"},{"location":"references/#automatically","title":"Automatically","text":"<p>Kapitan has built in capabilities to initialise its references on creation, using an elegant combination of primary and secondary functions. This is extremely powerful because it allows for you to make sure they are always initialised with sensible values.</p>"},{"location":"references/#primary-functions","title":"primary functions","text":"<p>To automate the creation of the reference, you can add one of the following primary functions to the reference tag by using the syntax <code>||primary_function:param1:param2</code></p> <p>For instance, to automatically initialise a reference with a random string with a lenght of 32 characters, you can use the <code>random</code> primary function</p> <pre><code>```yaml\nparameters:\n  ...\n  mysql:\n    root_password: ?{${backend}:targets/${target_name}/mysql/root_password||random:str:32}\n  ...\n```\n</code></pre> <p>Initialise non existent references</p> <p>The first operator here <code>||</code> is more similar to a logical OR. </p> <ul> <li>If the reference file does not exist, Kapitan will use the function to initialise it</li> <li>If the reference file exists, no functions will run.</li> </ul> <p>Automate secret rotation with ease</p> <p>You can take advantage of it to implement easy rotation of secrets. Simply delete the reference files, and run <code>kapitan compile</code>: let Kapitan do the rest.</p> randomprivate keysbasicauthreveal strintloweralphaupperalphaloweralphanumupperalphanumspecial <p>Generator function for alphanumeric characters, will be url-token-safe</p> <pre><code>?{${backend}:targets/${target_name}/mysql/root_password||random:str}\n</code></pre> <p>generator function for digits (0-9)</p> <pre><code>?{${backend}:targets/${target_name}/mysql/root_password||random:int}\n</code></pre> <p>generator function for lowercase letters (a-z)</p> <pre><code>?{${backend}:targets/${target_name}/mysql/root_password||random:loweralpha}\n</code></pre> <p>generator function for uppercase letters (A-Z)</p> <pre><code>?{${backend}:targets/${target_name}/mysql/root_password||random:upperalpha}\n</code></pre> <p>generator function for lowercase letters and numbers (a-z and 0-9)</p> <pre><code>?{${backend}:targets/${target_name}/mysql/root_password||random:loweralphanum}\n</code></pre> <p>generator function for uppercase letters and numbers (A-Z and 0-9)</p> <pre><code>?{${backend}:targets/${target_name}/mysql/root_password||random:upperalphanum}\n</code></pre> <p>generator function for alphanumeric characters and given special characters</p> <pre><code>?{${backend}:targets/${target_name}/mysql/root_password||random:special}\n</code></pre> rsaed25519publickeyrsapublic <p>Generates an RSA 4096 private key (PKCS#8). You can optionally pass the key size </p> <pre><code>?{${backend}:targets/${target_name}/private_key||rsa}\n</code></pre> <p>Generates a ed25519 private key (PKCS#8)</p> <pre><code>?{${backend}:targets/${target_name}/private_key||ed25519}\n</code></pre> <p>Derives the public key from a revealed private key</p> <pre><code>?{${backend}:targets/${target_name}/private_key||rsa}\n?{${backend}:targets/${target_name}/public_key||reveal:targets/${target_name}/private_key|publickey}\n</code></pre> <p>DEPRECATED: use <code>||publickey</code></p> <p>Generates a base64 encoded pair of <code>username:password</code></p> <pre><code>?{${backend}:targets/${target_name}/apache_basicauth||basicauth:username:password}\n</code></pre> <p>Reveals the content of another reference, useful when deriving public keys or a reference requires a different encoding or the same value.</p> <pre><code>?{${backend}:targets/${target_name}/secret||random:str}\n?{${backend}:targets/${target_name}/base64_secret||reveal:targets/${target_name}/secret|base64}\n</code></pre> <p>attention when rotating secrets used with <code>reveal</code></p> <p>If you use reveal to initialise a reference, like <code>my_reference||reveal:source_reference</code> the <code>my_reference</code> will not be automatically updated if <code>source_reference</code> changes. Please make sure you also re-initialise <code>my_reference</code> correctly</p>"},{"location":"references/#secondary-functions","title":"secondary functions","text":"base64sha256 <p>base64 encodes your reference</p> <pre><code>?{${backend}:targets/${target_name}/secret||random:str|base64}\n</code></pre> <p>sha256 hashes your reference <code>param1</code>: <code>salt</code></p> <pre><code>?{${backend}:targets/${target_name}/secret||random:str|sha256}\n</code></pre>"},{"location":"references/#reveal-references","title":"Reveal references","text":"<p>You can reveal the secrets referenced in the outputs of <code>kapitan compile</code> via:</p> <pre><code>```shell\nkapitan refs --reveal -f path/to/rendered/template\n```\n</code></pre> <p>For example, <code>compiled/minikube-mysql/manifests/mysql_secret.yml</code> with the following content:</p> <pre><code>```yaml\napiVersion: v1\ndata:\n  MYSQL_ROOT_PASSWORD: ?{gpg:targets/minikube-mysql/mysql/password:ec3d54de}\n  MYSQL_ROOT_PASSWORD_SHA256: ?{gpg:targets/minikube-mysql/mysql/password_sha256:122d2732}\nkind: Secret\nmetadata:\n  annotations: {}\n  labels:\n    name: example-mysql\n  name: example-mysql\n  namespace: minikube-mysql\ntype: Opaque\n```\n</code></pre> <p>can be revealed as follows:</p> <pre><code>```shell\nkapitan refs --reveal -f compiled/minikube-mysql/manifests/mysql_secret.yml\n```\n</code></pre> <p>This will substitute the referenced secrets with the actual decrypted secrets stored at the referenced paths and display the file content.</p> <p>You can also use:</p> <pre><code>```shell\nkapitan refs --reveal --ref-file refs/targets/all-glob/mysql/password\n```\n</code></pre> <p>or</p> <pre><code>```shell\nkapitan refs --reveal --tag \"?{base64:targets/all-glob/mysql/password}\"\n# or\nkapitan refs --reveal --tag \"?{base64:targets/all-glob/mysql/password:3192c15c}\"\n```\n</code></pre> <p>for more convenience.</p>"},{"location":"references/#embedded-refs","title":"Embedded refs","text":"<p>Please refer to the CLI reference</p>"},{"location":"references/#yaml-subvars-references","title":"YAML SubVars References","text":"<p>Kapitan is also able to use access specific keys in YAML content by using subvars.</p> <p>For instance given a reference <code>plain:larder</code> with content:</p> <pre><code>```yaml\nfood:\n  apples: 1\n```\n</code></pre> <p>I could now have an inventory variable like:</p> <pre><code>```yaml\nparameters:\n  number_of_apples: ?{plain:larder@food.apple}\n```\n</code></pre>"},{"location":"references/#using-subvars-to-ingest-yaml-from-command-line-tools","title":"Using <code>subvars</code> to ingest yaml from command line tools","text":"<p>Subvars can have a very practical use for storing YAML outputs coming straight from other tools. For instance, I could use the GCP <code>gcloud</code> command to get all the information about a cluster, and write it into a reference</p> <pre><code>```shell\ngcloud container clusters describe \\\n  --project ${TARGET_NAME}-project \\\n  gke-cluster --zone europe-west1 --format yaml \\\n    | kapitan refs --write plain:clusters/${TARGET_NAME}/cluster -t ${TARGET_NAME} -f -\n```\n</code></pre> <p>knowing the output of <code>gcloud</code> to produce yaml that contain the following values:</p> <pre><code>```yaml\n...\nname: gke-cluster\nreleaseChannel:\n  channel: REGULAR\nselfLink: https://container.googleapis.com/v1/projects/kapicorp/locations/europe-west1/clusters/gke-cluster\n...\n```\n</code></pre> <p>I can not reference the link to the cluster in the inventory using:</p> <pre><code>```yaml\nparameters:\n  cluster:\n    name: ?{plain:clusters/${target_name}/cluster@name} \n    release_channel: ?{plain:clusters/${target_name}/cluster@releaseChannel.channel}\n    link: ?{plain:clusters/${target_name}/cluster@selfLink}\n```\n</code></pre> <p>Combined with a Jinja template, I could write automatically documentation containing the details of the clusters I use.</p> <pre><code>```text\n{% set p = inventory.parameters %}\n# Documentation for {{p.target_name}}\n\nCluster [{{p.cluster.name}}]({{p.cluster.link}}) has release channel {{p.cluster.release_channel}}\n```\n</code></pre>"},{"location":"references/#hashicorp-vault","title":"Hashicorp Vault","text":""},{"location":"references/#vaultkv","title":"<code>vaultkv</code>","text":"<p>Considering a key-value pair like <code>my_key</code>:<code>my_secret</code> in the path <code>secret/foo/bar</code> in a kv-v2(KV version 2) secret engine on the vault server, to use this as a secret use:</p> <pre><code>```shell\necho \"foo/bar:my_key\"  | kapitan refs --write vaultkv:path/to/secret_inside_kapitan -t &lt;target_name&gt; -f -\n```\n</code></pre> <p>To write a secret in the vault with kapitan use a ref tag with following structure:</p> <pre><code>```yaml\nparameters:\n  ...\n  secret:\n    my_secret: ?{vaultkv:targets/${target_name}/mypath:mount:path/in/vault:mykey||&lt;functions&gt;}\n  ...\n```\n</code></pre> <p>Leave <code>mount</code> empty to use the specified mount from vault params from the inventory (see below). Same applies to the <code>path/in/vault</code> where the ref path in kapitan gets taken as default value.  </p> <p>Parameters in the secret file are collected from the inventory of the target we gave from CLI <code>-t &lt;target_name&gt;</code>. If target isn't provided then kapitan will identify the variables from the environment when revealing secret.</p> <p>Environment variables that can be defined in kapitan inventory are <code>VAULT_ADDR</code>, <code>VAULT_NAMESPACE</code>, <code>VAULT_SKIP_VERIFY</code>, <code>VAULT_CLIENT_CERT</code>, <code>VAULT_CLIENT_KEY</code>, <code>VAULT_CAPATH</code> &amp; <code>VAULT_CACERT</code>. Extra parameters that can be defined in inventory are:</p> <ul> <li><code>auth</code>: specify which authentication method to use like <code>token</code>,<code>userpass</code>,<code>ldap</code>,<code>github</code> &amp; <code>approle</code></li> <li><code>mount</code>: specify the mount point of key's path. e.g if path=<code>alpha-secret/foo/bar</code> then <code>mount: alpha-secret</code> (default <code>secret</code>)</li> <li> <p><code>engine</code>: secret engine used, either <code>kv-v2</code> or <code>kv</code> (default <code>kv-v2</code>) Environment variables cannot be defined in inventory are <code>VAULT_TOKEN</code>,<code>VAULT_USERNAME</code>,<code>VAULT_PASSWORD</code>,<code>VAULT_ROLE_ID</code>,<code>VAULT_SECRET_ID</code>.</p> <pre><code>parameters:\n  kapitan:\n    secrets:\n      vaultkv:\n        auth: userpass\n        engine: kv-v2\n        mount: team-alpha-secret\n        VAULT_ADDR: http://127.0.0.1:8200\n        VAULT_NAMESPACE: CICD-alpha\n        VAULT_SKIP_VERIFY: false\n        VAULT_CLIENT_KEY: /path/to/key\n        VAULT_CLIENT_CERT: /path/to/cert\n</code></pre> </li> </ul>"},{"location":"references/#vaulttransit","title":"<code>vaulttransit</code>","text":"<p>Considering a key-value pair like <code>my_key</code>:<code>my_secret</code> in the path <code>secret/foo/bar</code> in a transit secret engine on the vault server, to use this as a secret use:</p> <pre><code>```shell\necho \"any.value:whatever-you_may*like\"  | kapitan refs --write vaulttransit:my_target/to/secret_inside_kapitan -t &lt;target_name&gt; -f -\n```\n</code></pre> <p>Parameters in the secret file are collected from the inventory of the target we gave from CLI <code>-t &lt;target_name&gt;</code>. If target isn't provided then kapitan will identify the variables from the environment when revealing secret.</p> <p>Environment variables that can be defined in kapitan inventory are <code>VAULT_ADDR</code>, <code>VAULT_NAMESPACE</code>, <code>VAULT_SKIP_VERIFY</code>, <code>VAULT_CLIENT_CERT</code>, <code>VAULT_CLIENT_KEY</code>, <code>VAULT_CAPATH</code> &amp; <code>VAULT_CACERT</code>. Extra parameters that can be defined in inventory are:</p> <ul> <li><code>auth</code>: specify which authentication method to use like <code>token</code>,<code>userpass</code>,<code>ldap</code>,<code>github</code> &amp; <code>approle</code></li> <li><code>mount</code>: specify the mount point of key's path. e.g if path=<code>my_mount</code> (default <code>transit</code>)</li> <li><code>crypto_key</code>: Name of the <code>encryption key</code> defined in vault</li> <li> <p><code>always_latest</code>: Always rewrap ciphertext to latest rotated crypto_key version Environment variables cannot be defined in inventory are <code>VAULT_TOKEN</code>,<code>VAULT_USERNAME</code>,<code>VAULT_PASSWORD</code>,<code>VAULT_ROLE_ID</code>,<code>VAULT_SECRET_ID</code>.</p> <pre><code>parameters:\n  kapitan:\n    vars:\n      target: my_target\n      namespace: my_namespace\n    secrets:\n      vaulttransit:\n        VAULT_ADDR: http://vault.example.com:8200\n        VAULT_TOKEN: s.i53a1DL83REM61UxlJKLdQDY\n        VAULT_SKIP_VERIFY: \"True\"\n        auth: token\n        mount: transit\n        crypto_key: new_key\n        always_latest: False\nparameters:\n  target_name: secrets\n  kapitan:\n    secrets:\n      vaulttransit:\n        VAULT_ADDR: http://127.0.0.1:8200\n        VAULT_TOKEN: s.i53a1DL83REM61UxlJKLdQDY\n        VAULT_SKIP_VERIFY: \"True\"\n        auth: token\n        mount: transit\n        crypto_key: key\n        always_latest: False\n</code></pre> </li> </ul>"},{"location":"references/#azure-kms-secret-backend","title":"Azure KMS Secret Backend","text":"<p>To encrypt secrets using keys stored in Azure's Key Vault, a <code>key_id</code> is required to identify an Azure key object uniquely. It should be of the form <code>https://{keyvault-name}.vault.azure.net/{object-type}/{object-name}/{object-version}</code>.</p>"},{"location":"references/#defining-the-kms-key","title":"Defining the KMS key","text":"<p>This is done in the inventory under <code>parameters.kapitan.secrets</code>.</p> <pre><code>```yaml\nparameters:\n  kapitan:\n    vars:\n      target: ${target_name}\n      namespace: ${target_name}\n    secrets:\n      azkms:\n        key: 'https://&lt;keyvault-name&gt;.vault.azure.net/keys/&lt;object-name&gt;/&lt;object-version&gt;'\n```\n</code></pre> <p>The key can also be specified using the <code>--key</code> flag</p>"},{"location":"references/#creating-a-secret","title":"Creating a secret","text":"<p>Secrets can be created using any of the methods described in the \"creating your secret\" section.</p> <p>For example, if the key is defined in the <code>prod</code> target file</p> <pre><code>```shell\necho \"my_encrypted_secret\" | kapitan refs --write azkms:path/to/secret_inside_kapitan -t prod -f -\n```\n</code></pre> <p>Using the <code>--key</code> flag and a <code>key_id</code></p> <pre><code>```shell\necho \"my_encrypted_secret\" | kapitan refs --write azkms:path/to/secret_inside_kapitan --key=&lt;key_id&gt; -f -\n```\n</code></pre>"},{"location":"references/#referencing-and-revealing-a-secret","title":"Referencing and revealing a secret","text":"<p>Secrets can be referenced and revealed in any of the ways described above.</p> <p>For example, to reveal the secret stored at <code>path/to/secret_inside_kapitan</code></p> <pre><code>```shell\nkapitan refs --reveal --tag \"?{azkms:path/to/secret_inside_kapitan}\"\n```\n</code></pre> <p>Note: Cryptographic algorithm used for encryption is rsa-oaep-256.</p>"},{"location":"related/","title":"Related projects","text":"<ul> <li>Tesoro - Kubernetes Admission Controller for Kapitan Secrets</li> <li>Kapitan Reference - Reference repository to get started</li> <li>sublime-jsonnet-syntax - Jsonnet syntax highlighting for Sublime Text</li> <li>language-jsonnet - Jsonnet syntax highlighting for Atom</li> <li>vim-jsonnet - Jsonnet plugin for Vim (requires a vim plugin manager)</li> </ul>"},{"location":"support/","title":"Get support with Kapitan","text":""},{"location":"support/#community","title":"Community","text":"<ul> <li>Join us on kubernetes.slack.com <code>#kapitan</code>(Get invited)</li> <li>Follow us on Twitter @kapitandev.</li> <li>Website <code>https://kapitan.dev</code></li> <li>Mailing List kapitan-discuss@googlegroups.com(Subscribe)</li> </ul>"},{"location":"support/#resources","title":"Resources","text":"<ul> <li>Main Blog, articles and tutorials: Kapitan Blog</li> <li>Generators and reference kapitan repository: Kapitan Reference</li> <li>Kapitan Reference: our reference repository to get started with Kapitan.</li> </ul>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#community","title":"community","text":"<ul> <li>Proposals</li> <li>Kapitan Code</li> <li>Documentation</li> <li>Sponsor Us</li> </ul>"},{"location":"tags/#kadet","title":"kadet","text":"<ul> <li>Kadet</li> </ul>"},{"location":"tags/#kubernetes","title":"kubernetes","text":"<ul> <li>Kadet</li> </ul>"},{"location":"kap_proposals/kap_0_kadet/","title":"Kadet","text":"<p>This introduces a new experimental input type called Kadet.</p> <p>Kadet is essentially a Python module offering a set of classes and functions to define objects which will compile to JSON or YAML. A complete example is available in <code>examples/kubernetes/components/nginx</code>.</p> <p>Author: @ramaro</p>","tags":["kubernetes","kadet"]},{"location":"kap_proposals/kap_0_kadet/#overview","title":"Overview","text":"","tags":["kubernetes","kadet"]},{"location":"kap_proposals/kap_0_kadet/#baseobj","title":"BaseObj","text":"<p>BaseObj implements the basic object implementation that compiles into JSON or YAML. Setting keys in <code>self.root</code> means they will be in the compiled output. Keys can be set as an hierarchy of attributes (courtesy of addict) The <code>self.body()</code> method is reserved for setting self.root on instantiation:</p> <p>The example below:</p> <pre><code>class MyApp(BaseObj):\n def body(self):\n   self.root.name = \"myapp\"\n   self.root.inner.foo = \"bar\"\n   self.root.list = [1, 2, 3]\n</code></pre> <p>compiles into:</p> <pre><code>---\nname: myapp\ninner:\n  foo: bar\nlist:\n  - 1\n  - 2\n  - 3\n</code></pre> <p>The <code>self.new()</code> method can be used to define a basic constructor. <code>self.need()</code> checks if a key is set and errors if it isn't (with an optional custom error message). <code>kwargs</code> that are passed onto a new instance of BaseObj are always accessible via <code>self.kwargs</code> In this example, MyApp needs <code>name</code> and <code>foo</code> to be passed as kwargs.</p> <pre><code>class MyApp(BaseObj):\n def new(self):\n   self.need(\"name\")\n   self.need(\"foo\", msg=\"please provide a value for foo\")\n\n def body(self):\n   self.root.name = self.kwargs.name\n   self.root.inner.foo = self.kwargs.foo\n   self.root.list = [1, 2, 3]\n\nobj = MyApp(name=\"myapp\", foo=\"bar\")\n</code></pre>","tags":["kubernetes","kadet"]},{"location":"kap_proposals/kap_0_kadet/#setting-a-skeleton","title":"Setting a skeleton","text":"<p>Defining a large body with Python can be quite hard and repetitive to read and write. The <code>self.update_root()</code> method allows importing a YAML/JSON file to set the skeleton of self.root.</p> <p>MyApp's skeleton can be set instead like this:</p> <pre><code>#skel.yml\n---\nname: myapp\ninner:\n  foo: bar\nlist:\n  - 1\n  - 2\n  - 3\n</code></pre> <pre><code>class MyApp(BaseObj):\n def new(self):\n   self.need(\"name\")\n   self.need(\"foo\", msg=\"please provide a value for foo\")\n   self.update_root(\"path/to/skel.yml\")\n</code></pre> <p>Extending a skeleton'd MyApp is possible just by implementing <code>self.body()</code>:</p> <pre><code>class MyApp(BaseObj):\n def new(self):\n   self.need(\"name\")\n   self.need(\"foo\", msg=\"please provide a value for foo\")\n   self.update_root(\"path/to/skel.yml\")\n\n def body(self):\n   self.set_replicas()\n   self.root.metadata.labels = {\"app\": \"mylabel\"}\n\ndef set_replicas(self):\n   self.root.spec.replicas = 5\n</code></pre>","tags":["kubernetes","kadet"]},{"location":"kap_proposals/kap_0_kadet/#inheritance","title":"Inheritance","text":"<p>Python inheritance will work as expected:</p> <pre><code>class MyOtherApp(MyApp):\n  def new(self):\n    super().new()  # MyApp's new()\n    self.need(\"size\")\n\ndef body(self):\n   super().body()  #  we want to extend MyApp's body\n   self.root.size = self.kwargs.size\n   del self.root.list  # get rid of \"list\"\n\nobj = MyOtherApp(name=\"otherapp1\", foo=\"bar2\", size=3)\n</code></pre> <p>compiles to:</p> <pre><code>---\nname: otherapp1\ninner:\n  foo: bar2\nreplicas: 5\nsize: 3\n</code></pre>","tags":["kubernetes","kadet"]},{"location":"kap_proposals/kap_0_kadet/#components","title":"Components","text":"<p>A component in Kadet is a python module that must implement a <code>main()</code> function returning an instance of<code>BaseObj</code>. The inventory is also available via the <code>inventory()</code> function.</p> <p>For example, a <code>tinyapp</code> component:</p> <pre><code># components/tinyapp/__init__.py\nfrom kapitan.inputs.kadet import BaseOBj, inventory\ninv = inventory() # returns inventory for target being compiled\n\nclass TinyApp(BaseObj):\n  def body(self):\n    self.root.foo = \"bar\"\n    self.root.replicas = inv.parameters.tinyapp.replicas\n\ndef main():\n  obj = BaseOb()\n  obj.root.deployment = TinyApp() # will compile into deployment.yml\n  return obj\n</code></pre> <p>An inventory class must be created for <code>tinyapp</code>:</p> <pre><code># inventory/classes/components/tinyapp.yml\n\nparameters:\n  tinyapp:\n    replicas: 1\n  kapitan:\n    compile:\n    - output_path: manifests\n      input_type: kadet\n      output_type: yaml\n      input_paths:\n        - components/tinyapp\n</code></pre>","tags":["kubernetes","kadet"]},{"location":"kap_proposals/kap_0_kadet/#common-components","title":"Common components","text":"<p>A library in <code>--search-paths</code> (which now defaults to <code>.</code> and <code>lib/</code>) can also be a module that kadet components import. It is loaded using the <code>load_from_search_paths()</code>:</p> <pre><code>kubelib = load_from_search_paths(\"kubelib\") # lib/kubelib/__init__.py\n\ndef main():\n  obj = BaseObj()\n  obj.root.example_app_deployment = kubelib.Deployment(name=\"example-app\")\n  return obj\n</code></pre>","tags":["kubernetes","kadet"]},{"location":"kap_proposals/kap_10_azure_key_vault/","title":"Support for Azure Key Management","text":"<p>This feature will enable users to encrypt secrets using keys stored in Azure's Key Vault. The <code>azkms</code> keyword will be used to access the azure key management backend.</p>"},{"location":"kap_proposals/kap_10_azure_key_vault/#specification","title":"Specification","text":"<p><code>key_id</code> uniquely identifies an Azure key object and it's version stored in Key Vault. It is of the form <code>https://{keyvault-name}.vault.azure.net/{object-type}/{object-name}/{object-version}</code>. It needs to be made accessible to kapitan in one of the following ways:</p> <ul> <li>As a part of target</li> </ul> <pre><code>parameters:\n  kapitan:\n    secrets:\n      azkms:\n        key: key_id #eg https://kapitanbackend.vault.azure.net/keys/myKey/deadbeef\n</code></pre> <ul> <li>As a flag</li> </ul> <pre><code>kapitan refs --key=&lt;key_id&gt; --write azkms:/path/to/secret -f file_with_secret_data.txt\n</code></pre>"},{"location":"kap_proposals/kap_10_azure_key_vault/#using-a-key-to-encrypt-a-secret","title":"Using a key to encrypt a secret","text":"<p>The following command will be used to encrypt a secret (using the specified key from Key Vault) and save it in the <code>refs-path</code> along with it's metadata</p> <pre><code>echo \"my_treasured_secret\"  | kapitan refs --write azkms:path/to/secret_inside_kapitan -t &lt;target_name&gt; -f -\n</code></pre> <p>The <code>-t &lt;target_name&gt;</code> is used to get the information about key_id.</p> <p>Once the secret is Base64 encoded and encrypted using the key, it will be stored in <code>path/to/secret_inside_kapitan</code> as</p> <pre><code>data: bXlfdHJlYXN1cmVkX3NlY3JldAo=\nencoding: original\nkey: https://kapitanbackend.vault.azure.net/keys/myKey/deadbeef\ntype: azkms\n</code></pre> <p>note Cryptographic algorithm used for encryption would be rsa-oaep-256. Optimal Asymmetric Encryption Padding (OAEP) is a padding scheme often used together with RSA encryption.</p>"},{"location":"kap_proposals/kap_10_azure_key_vault/#referencing-a-secret","title":"referencing a secret","text":"<p>Secrets can be refered using <code>?{azkms:path/to/secret_id}</code> e.g.</p> <pre><code>parameter:\n    mysql:\n        storage: 10G\n        storage_class: standard\n        image: mysql:latest\n        users:\n            root:\n                password: ?{azkms:path/to/secret}\n</code></pre>"},{"location":"kap_proposals/kap_10_azure_key_vault/#revealing-a-secret","title":"Revealing a secret","text":"<p>After compilation, the secret reference will be postfixed with 8 characters from the sha256 hash of the retrieved password/secret</p> <pre><code>apiVersion: v1\ndata:\n  MYSQL_ROOT_PASSWORD: ?{azkms:path/to/secret:deadbeef}\nkind: Secret\nmetadata:\n  labels:\n    name: example-mysql\n  name: example-mysql\n  namespace: minikube-mysql\ntype: Opaque\n</code></pre> <p>To reveal the secret, the following command will be used <code>$ kapitan ref --reveal -f compiled/file/containing/secret</code></p>"},{"location":"kap_proposals/kap_10_azure_key_vault/#dependencies","title":"Dependencies","text":"<ul> <li>azure-keyvault-keys</li> <li>azure-identity</li> </ul> <p>note Kapitan will not be responsible for authentication or access management to Azure</p>"},{"location":"kap_proposals/kap_11_hashicorp_vault_transit/","title":"Hashicorp Vault Transit","text":"<p>This feature allows the user to fetch secrets from Hashicorp Vault, with the new secret backend keyword 'vaulttransit'.</p> <p>Author: @xqp @Moep90</p>"},{"location":"kap_proposals/kap_11_hashicorp_vault_transit/#specification","title":"Specification","text":"<p>The following variables need to be exported to the environment(depending on authentication used) where you will run <code>kapitan refs --reveal</code> in order to authenticate to your HashiCorp Vault instance:</p> <ul> <li>VAULT_ADDR: URL for vault</li> <li>VAULT_SKIP_VERIFY=true: if set, do not verify presented TLS certificate before communicating with Vault server. Setting this variable is not recommended except during testing</li> <li>VAULT_TOKEN: token for vault or file (~/.vault-tokens)</li> <li>VAULT_ROLE_ID: required by approle</li> <li>VAULT_SECRET_ID: required by approle</li> <li>VAULT_USERNAME: username to login to vault</li> <li>VAULT_PASSWORD: password to login to vault</li> <li>VAULT_CLIENT_KEY: the path to an unencrypted PEM-encoded private key matching the client certificate</li> <li>VAULT_CLIENT_CERT: the path to a PEM-encoded client certificate for TLS authentication to the Vault server</li> <li>VAULT_CACERT: the path to a PEM-encoded CA cert file to use to verify the Vault server TLS certificate</li> <li>VAULT_CAPATH: the path to a directory of PEM-encoded CA cert files to verify the Vault server TLS certificate</li> <li>VAULT_NAMESPACE: specify the Vault Namespace, if you have one</li> </ul> <p>Considering any stringdata like <code>any.value:whatever-you_may*like</code> ( in our case let\u2019s encrypt <code>any.value:whatever-you_may*like</code> with vault transit ) using the key <code>2022-02-13-test</code> in a transit secret engine with mount <code>mytransit</code> on the vault server, to use this as a secret either follow:</p> <pre><code>echo \"any.value:whatever-you_may*like\" &gt; somefile.txt\nkapitan refs --write vaulttransit:&lt;target_name&gt;/to/secret_inside_kapitan --file somefile.txt --target &lt;target_name&gt;\n</code></pre> <p>or in a single line</p> <pre><code>echo \"any.value:whatever-you_may*like\"  | kapitan refs --write vaulttransit:&lt;target_name&gt;/to/secret_inside_kapitan -t &lt;target_name&gt; -f -\n</code></pre> <p>The entire string \"any.value:whatever-you_may*like\" will be encrypted by vault and looks like this in return: <code>vault:v2:Jhn3UzthKcJ2s+sEiO60EUiDmuzqUC4mMBWp2Vjg/DGl+GDFEDIPmAQpc5BdIefkplb6yrJZq63xQ9s=</code>. This then gets base64 encoded and stored in the secret_inside_kapitan. Now secret_inside_kapitan contains the following</p> <pre><code>data: dmF1bHQ6djI6SmhuM1V6dGhLY0oycytzRWlPNjBFVWlEbXV6cVVDNG1NQldwMlZqZy9ER2wrR0RGRURJUG1BUXBjNUJkSWVma3BsYjZ5ckpacTYzeFE5cz0=\nencoding: original\ntype: vaulttransit\nvault_params:\n  VAULT_ADDR: http://127.0.0.1:8200\n  VAULT_SKIP_VERIFY: 'True'\n  VAULT_TOKEN: s.i53a1DL83REM61UxlJKLdQDY\n  auth: token\n  crypto_key: key\n  mount: transit\n  always_latest: false\n</code></pre> <p>Encoding tells the type of data given to kapitan, if it is <code>original</code> then after decoding base64 we'll get the original secret and if it is <code>base64</code> then after decoding once we still have a base64 encoded secret and have to decode again. Parameters in the secret file are collected from the inventory of the target we gave from CLI <code>--target my_target</code>. If target isn't provided then kapitan will identify the variables from the environment, but providing <code>auth</code> is necessary as a key inside target parameters like the one shown:</p> <pre><code>parameters:\n  kapitan:\n    vars:\n      target: my_target\n      namespace: my_namespace\n    secrets:\n      vaulttransit:\n        VAULT_ADDR: http://vault.example.com:8200\n        VAULT_TOKEN: s.i53a1DL83REM61UxlJKLdQDY\n        VAULT_SKIP_VERIFY: \"True\"\n        auth: token\n        mount: transit\n        crypto_key: new_key   \n        always_latest: False\n</code></pre> <p>Environment variables that can be defined in kapitan inventory are <code>VAULT_ADDR</code>, <code>VAULT_NAMESPACE</code>, <code>VAULT_SKIP_VERIFY</code>, <code>VAULT_CLIENT_CERT</code>, <code>VAULT_CLIENT_KEY</code>, <code>VAULT_CAPATH</code> &amp; <code>VAULT_CACERT</code>. Extra parameters that can be defined in inventory are:</p> <ul> <li><code>auth</code>: specify which authentication method to use like <code>token</code>,<code>userpass</code>,<code>ldap</code>,<code>github</code> &amp; <code>approle</code></li> <li><code>mount</code>: specify the mount point of key's path. e.g if path=<code>alpha-secret/foo/bar</code> then <code>mount: alpha-secret</code> (default <code>secret</code>)</li> <li><code>crypto_key</code>: Name of the <code>encryption key</code> defined in vault</li> <li><code>always_latest</code>: Always rewrap ciphertext to latest rotated <code>crypto_key</code> version Environment variables should NOT be defined in inventory are <code>VAULT_TOKEN</code>,<code>VAULT_USERNAME</code>,<code>VAULT_PASSWORD</code>,<code>VAULT_ROLE_ID</code>,<code>VAULT_SECRET_ID</code>. This makes the secret_inside_kapitan file accessible throughout the inventory, where we can use the secret whenever necessary like <code>?{vaulttransit:${target_name}/secret_inside_kapitan}</code></li> </ul> <p>Following is the example file having a secret and pointing to the vault <code>?{vaulttransit:${target_name}/secret_inside_kapitan}</code></p> <pre><code>parameters:\n  releases:\n    app_version: latest\n  app:\n    image: app:app-tag\n    release: ${releases:app_version}\n    replicas: ${replicas}\n    args:\n      - --verbose=${verbose}\n      - --password=?{vaulttransit:${target_name}/secret_inside_kapitan||random:str}\n</code></pre> <p>when <code>?{vaulttransit:${target_name}/secret_inside_kapitan}</code> is compiled, it will look same with an 8 character prefix of sha256 hash added at the end like:</p> <pre><code>kind: Deployment\nmetadata:\n  name: app\n  namespace: my_namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: app\n    spec:\n      containers:\n        - args:\n            - --verbose=True\n            - --password=?{vaulttransit:${target_name}/secret_inside_kapitan||random:str}\n          image: app:app-tag\n          name: app\n</code></pre> <p>Only the user with the required tokens/permissions can reveal the secrets. Please note that the roles and permissions will be handled at the Vault level. We need not worry about it within Kapitan. Use the following command to reveal the secrets:</p> <pre><code>kapitan refs --reveal -f compile/file/containing/secret\n</code></pre> <p>Following is the result of the app-deployment.md file after Kapitan reveal.</p> <pre><code>kind: Deployment\nmetadata:\n  name: app\n  namespace: my_namespace\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: app\n    spec:\n      containers:\n        - args:\n            - --verbose=True\n            - --password=\"any.value:whatever-you_may*like\"\n          image: app:app-tag\n          name: app\n</code></pre>"},{"location":"kap_proposals/kap_11_hashicorp_vault_transit/#vault-policies","title":"Vault policies","text":"<pre><code>path \"mytransit/encrypt/2022-02-13-test\" {\n    capabilities = [ \"create\", \"update\" ]\n}\n\npath \"mytransit/decrypt/2022-02-13-test\" {\n    capabilities = [ \"create\", \"update\" ]\n}\n</code></pre>"},{"location":"kap_proposals/kap_11_hashicorp_vault_transit/#dependencies","title":"Dependencies","text":"<ul> <li>hvac is a python client for Hashicorp Vault</li> </ul>"},{"location":"kap_proposals/kap_1_external_dependencies/","title":"External dependencies","text":"<p>This features allows kapitan to fetch files from online repositories/sources during compile and store in a particular target directory.</p> <p>Author: @yoshi-1224</p>"},{"location":"kap_proposals/kap_1_external_dependencies/#specification","title":"Specification","text":"<p>Specify the files to be fetched as follows:</p> <pre><code>parameters:\n kapitan:\n  dependencies:\n   - type: git | http[s]\n     output_path: &lt;output_path&gt;\n     source: &lt;git/http[s]_url&gt;    \n</code></pre> <p>The output path is the path to save the dependency into. For example, it could be <code>/components/external/manifest.jsonnet</code>. Then, the user can specify the fetched file as a <code>kapitan.compile</code> item along with the locally-created files.  </p> <p>Git type may also include <code>ref</code> and <code>subdir</code> parameters as illustrated below:</p> <pre><code>- type: git\n  output_path: &lt;output_path&gt;\n  source: &lt;git_url&gt;\n  subdir: relative/path/in/repository\n  ref: &lt;commit_hash/branch/tag&gt;\n  force_fetch: &lt;bool&gt;\n</code></pre> <p>If the file already exists at <code>output_path</code>, the fetch will be skipped. For fresh fetch of the dependencies, users may add <code>--fetch</code> option as follows:</p> <pre><code>kapitan compile --fetch\n</code></pre> <p>Users can also add the <code>force_fetch: true</code> option to the <code>kapitan.dependencies</code> in the inventory in order to force fetch of the dependencies of the target every time.</p>"},{"location":"kap_proposals/kap_1_external_dependencies/#implementation-details","title":"Implementation details","text":""},{"location":"kap_proposals/kap_1_external_dependencies/#dependencies","title":"Dependencies","text":"<ul> <li>GitPython module (and git executable) for git type</li> <li>requests module for http[s]</li> <li>(optional) tqdm for reporting download progress</li> </ul>"},{"location":"kap_proposals/kap_2_helm_charts_input_type/","title":"Helm Charts Input Type","text":"<p>This will allow kapitan, during compilation, to overwrite the values in user-specified helm charts using its inventory by calling the Go &amp; Sprig template libraries. The helm charts can be specified via local path, and users may download the helm chart via external-dependency feature (of http[s] type).</p> <p>Author: @yoshi-1224</p>"},{"location":"kap_proposals/kap_2_helm_charts_input_type/#specification","title":"Specification","text":"<p>This feature basically follows the <code>helm template</code> command available. This will run after the fetching of the external dependencies takes place, such that users can simultaneously specify the fetch as well as the import of a helm chart dependency.</p>"},{"location":"kap_proposals/kap_2_helm_charts_input_type/#semantics","title":"Semantics","text":"<pre><code>kapitan:\n  compile:\n    - input_type: helm\n      input_path: &lt;path_to_chart_dir&gt; \n      output_path: &lt;output_path&gt;\n      set-file:\n        - &lt;optional_file_path&gt;\n        - ...\n      values_file: &lt;optional_values_file&gt;\n      namespace: &lt;optional_namespace&gt;\n</code></pre> <p>This mostly maps to the options available to <code>helm template</code> command (refer to here).</p>"},{"location":"kap_proposals/kap_2_helm_charts_input_type/#implementation-details","title":"Implementation details","text":"<p>C-binding between Helm (Go) and Kapitan (Python) will be created. Helm makes use of two template libraries, namely, text/template and Sprig. The code for <code>helm template</code> command will be converted into shared object (.so) using CGo, which exposes C interface that kapitan (i.e. CPython) could use. The source code for <code>helm template</code> command is found here. This file will be modified to</p> <ol> <li>remove redundant options</li> <li>expose C-interface for Kapitan</li> </ol>"},{"location":"kap_proposals/kap_2_helm_charts_input_type/#dependencies","title":"Dependencies","text":"<ul> <li>(possibly) pybindgen</li> </ul>"},{"location":"kap_proposals/kap_3_schema_validation/","title":"Schema Validation (for k8s)","text":"<p>If a yaml/json output is to be used as k8s manifest, users may specify its kind and have kapitan validate its structure during <code>kapitan compile</code>. The plan is to have this validation feature extendable to other outputs as well, such as terraform.</p> <p>Author: @yoshi-1224</p>"},{"location":"kap_proposals/kap_3_schema_validation/#specification","title":"Specification","text":"<p>The following inventory will validate the structure of Kubernetes Service manifest file in . <pre><code>parameters:\n  kapitan:\n    validate:\n       - output_type: kubernetes.service \n         version: 1.6.6\n         output_path: relative/path/in/target\n</code></pre> <p><code>version</code> parameter is optional: if omitted, the version will be set to the stable release of kubernetes (tbc).</p>"},{"location":"kap_proposals/kap_3_schema_validation/#implementation","title":"Implementation","text":"<ul> <li>The schemas will be downloaded by requests from this repository.</li> <li>Caching of schema will also be implemented.</li> </ul>"},{"location":"kap_proposals/kap_3_schema_validation/#dependencies","title":"Dependencies","text":"<ul> <li>jsonschema to validate the output yaml/json against the correct schema</li> </ul>"},{"location":"kap_proposals/kap_4_standalone_executable/","title":"Standalone Kapitan Executable (Discontinued)","text":"<p>Create a portable (i.e. static) kapitan binary for users. This executable will be made available for each release on Github. The target/tested platform is Debian 9 (possibly Windows to be supported in the future).</p> <p>Criteria:</p> <ul> <li>speed of the resulting binary</li> <li>size of the resulting binary</li> <li>portability of the binary (single-file executable or has an accompanying folder)</li> <li>cross-platform</li> <li>actively maintained</li> <li>supports Python 3.6, 3.7</li> </ul> <p>Author: @yoshi-1224</p>"},{"location":"kap_proposals/kap_4_standalone_executable/#tools-to-be-explored","title":"Tools to be explored","text":"<ul> <li>(tentative first-choice) Pyinstaller</li> <li>(Alternative) nuitka (also part of GSoC 2019. It might soon support single-file executable output).</li> </ul>"},{"location":"kap_proposals/kap_5_ref_types_redesign/","title":"Ref Types Redesign","text":"<p>Redesign Kapitan Secrets and rename them as <code>References</code> or <code>Ref</code>.</p> <p>Breaking changes:</p> <ul> <li><code>$ kapitan secrets</code> is replaced with <code>$ kapitan refs</code></li> <li>the default secrets directory <code>./secrets/</code> changes to <code>./refs/</code></li> <li>the <code>--secrets-path</code> flag changes to <code>--refs-path</code></li> <li>ref ref type is renamed to base64 e.g.<code>?{ref:some/ref}</code> into <code>?{base64:some/ref}</code></li> </ul> <p>Status: In progress</p> <p>Author: @ramaro</p>"},{"location":"kap_proposals/kap_5_ref_types_redesign/#proposal","title":"Proposal","text":"<p>Rename <code>Secrets</code> into <code>Ref</code> (or <code>References</code>) to improve consistency and meaning of the backend types by removing the <code>ref</code> backend and introducting new backends:</p> Type Description Encrypted? Compiles To gpg GnuPG Yes hashed tag gkms Google KMS Yes hashed tag awskms Amazon KMS Yes hashed tag base64 base64 No hashed tag plain plain text No plain text <p>The type value will now need to be representative of the way a reference is stored via its backend.</p> <p>A new <code>plain</code> backend type is introduced and will compile into revealed state instead of a hashed tag.</p> <p>A new <code>base64</code> backend type will store a base64 encoded value as the backend suggests (replacing the old badly named <code>ref</code> backend).</p> <p>The command line for secrets will be instead:</p> <pre><code>kapitan refs --write gpg:my/secret1 ...\nkapitan refs --write base64:my/file ...\nkapitan refs --write plain:my/info ...\n</code></pre>"},{"location":"kap_proposals/kap_5_ref_types_redesign/#plain-backend","title":"plain backend","text":"<p>The <code>plain</code> backend type will allow referring to external state by updating refs programmatically (e.g. in your pipeline)</p> <p>For example, one can update the value of an environment variable and use <code>?{plain:my/user}</code> as a reference in a template:</p> <pre><code>echo $USER | kapitan refs --write plain:my/user -f -\n</code></pre> <p>Or update a docker image value as ref <code>?{plain:images/dev/envoy}</code>:</p> <pre><code>echo 'envoyproxy/envoy:v1.10.0' | kapitan refs --write plain:images/dev/envoy -f -\n</code></pre> <p>These references will be compiled into their values instead of hashed tags.</p>"},{"location":"kap_proposals/kap_5_ref_types_redesign/#base64-backend","title":"base64 backend","text":"<p>The <code>base64</code> backend type will function as the original <code>ref</code> type. Except that this time, the name is representative of what is actually happening :)</p>"},{"location":"kap_proposals/kap_5_ref_types_redesign/#refs-path","title":"Refs path","text":"<p>Refs will be stored by default in the <code>./refs</code> path set by <code>--refs-path</code> replacing the <code>--secrets-path</code> flag.</p>"},{"location":"kap_proposals/kap_5_ref_types_redesign/#background","title":"Background","text":""},{"location":"kap_proposals/kap_5_ref_types_redesign/#kapitan-secrets","title":"Kapitan Secrets","text":"<p>Kapitan Secrets allow referring to restricted information (passwords, private keys, etc...) in templates while also securely storing them.</p> <p>On compile, secret tags are updated into hashed tags which validate and instruct <code>Kapitan</code> how to reveal tags into decrypted or encoded information.</p>"},{"location":"kap_proposals/kap_5_ref_types_redesign/#kapitan-secrets-example","title":"Kapitan Secrets example","text":"<p>The following command creates a GPG encrypted secret with the contents of file.txt for recipient <code>ramaro@google.com</code> to read:</p> <pre><code>kapitan secrets --write gpg:my/secret1 -f file.txt --recipients ramaro@google.com\n</code></pre> <p>This secret can be referred to in a jsonnet compoment:</p> <pre><code>{\n    \"type\": \"app\",\n    \"name\": \"test_app\",\n    \"username\": \"user_one\",\n    \"password\": \"?{gpg:my/secret1}\"\n}\n</code></pre> <p>When this compoment is compiled, it looks like (note the hashed tag):</p> <pre><code>type: app\nname: test_app\nusername: user_one\npassword: ?{gpg:my/secret1:deadbeef}\n</code></pre> <p>A user with the required permissions can reveal the compiled component:</p> <pre><code>$ kapitan secrets --reveal -f compiled/mytarget/manifests/component.yml\n\ntype: app\nname: test_app\nusername: user_one\npassword: secret_content_of_file.txt\n</code></pre>"},{"location":"kap_proposals/kap_5_ref_types_redesign/#secret-backend-comparison","title":"Secret Backend Comparison","text":"<p>Kapitan today offers multiple secret backends:</p> Type Description Encrypted? Compiles To gpg GnuPG Yes hashed tag gkms Google KMS Yes hashed tag awskms Amazon KMS Yes hashed tag ref base64 No hashed tag <p>However, not all backends are encrypted - this is not consistent!</p> <p>The <code>ref</code> type is not encrypted as its purpose is to allow getting started with the Kapitan Secrets workflow without the need of setting up the encryption backends tooling (gpg, gcloud, boto, etc...)</p>"},{"location":"kap_proposals/kap_6_hashicorp_vault/","title":"Hashicorp Vault","text":"<p>This feature allows the user to fetch secrets from Hashicorp Vault, with the new secret backend keyword 'vaultkv'.</p> <p>Author: @vaibahvk @daminisatya</p>"},{"location":"kap_proposals/kap_6_hashicorp_vault/#specification","title":"Specification","text":"<p>The following variables need to be exported to the environment(depending on authentication used) where you will run <code>kapitan refs --reveal</code> in order to authenticate to your HashiCorp Vault instance:</p> <ul> <li>VAULT_ADDR: URL for vault</li> <li>VAULT_SKIP_VERIFY=true: if set, do not verify presented TLS certificate before communicating with Vault server. Setting this variable is not recommended except during testing</li> <li>VAULT_TOKEN: token for vault or file (~/.vault-tokens)</li> <li>VAULT_ROLE_ID: required by approle</li> <li>VAULT_SECRET_ID: required by approle</li> <li>VAULT_USERNAME: username to login to vault</li> <li>VAULT_PASSWORD: password to login to vault</li> <li>VAULT_CLIENT_KEY: the path to an unencrypted PEM-encoded private key matching the client certificate</li> <li>VAULT_CLIENT_CERT: the path to a PEM-encoded client certificate for TLS authentication to the Vault server</li> <li>VAULT_CACERT: the path to a PEM-encoded CA cert file to use to verify the Vault server TLS certificate</li> <li>VAULT_CAPATH: the path to a directory of PEM-encoded CA cert files to verify the Vault server TLS certificate</li> <li>VAULT_NAMESPACE: specify the Vault Namespace, if you have one</li> </ul> <p>Considering a key-value pair like <code>my_key</code>:<code>my_secret</code> ( in our case let\u2019s store <code>hello</code>:<code>batman</code> inside the vault ) in the path <code>secret/foo</code> in a kv-v2(KV version 2) secret engine on the vault server, to use this as a secret either follow:</p> <pre><code>echo \"foo:hello\" &gt; somefile.txt\nkapitan refs --write vaultkv:path/to/secret_inside_kapitan --file somefile.txt --target dev-sea\n</code></pre> <p>or in a single line</p> <pre><code>echo \"foo:hello\"  | kapitan refs --write vaultkv:path/to/secret_inside_kapitan -t dev-sea -f -\n</code></pre> <p>The entire string \"foo:hello\" is base64 encoded and stored in the secret_inside_kapitan. Now secret_inside_kapitan contains the following</p> <pre><code>data: Zm9vOmhlbGxvCg==\nencoding: original\ntype: vaultkv\nvault_params:\n  auth: token\n</code></pre> <p>Encoding tells the type of data given to kapitan, if it is <code>original</code> then after decoding base64 we'll get the original secret and if it is <code>base64</code> then after decoding once we still have a base64 encoded secret and have to decode again. Parameters in the secret file are collected from the inventory of the target we gave from CLI <code>--target dev-sea</code>. If target isn't provided then kapitan will identify the variables from the environment, but providing <code>auth</code> is necessary as a key inside target parameters like the one shown:</p> <pre><code>parameters:\n  kapitan:\n    secrets:\n      vaultkv:\n        auth: userpass\n        engine: kv-v2\n        mount: team-alpha-secret\n        VAULT_ADDR: http://127.0.0.1:8200\n        VAULT_NAMESPACE: CICD-alpha\n        VAULT_SKIP_VERIFY: false\n        VAULT_CLIENT_KEY: /path/to/key\n        VAULT_CLIENT_CERT: /path/to/cert\n</code></pre> <p>Environment variables that can be defined in kapitan inventory are <code>VAULT_ADDR</code>, <code>VAULT_NAMESPACE</code>, <code>VAULT_SKIP_VERIFY</code>, <code>VAULT_CLIENT_CERT</code>, <code>VAULT_CLIENT_KEY</code>, <code>VAULT_CAPATH</code> &amp; <code>VAULT_CACERT</code>. Extra parameters that can be defined in inventory are:</p> <ul> <li><code>auth</code>: specify which authentication method to use like <code>token</code>,<code>userpass</code>,<code>ldap</code>,<code>github</code> &amp; <code>approle</code></li> <li><code>mount</code>: specify the mount point of key's path. e.g if path=<code>alpha-secret/foo/bar</code> then <code>mount: alpha-secret</code> (default <code>secret</code>)</li> <li><code>engine</code>: secret engine used, either <code>kv-v2</code> or <code>kv</code> (default <code>kv-v2</code>) Environment variables cannot be defined in inventory are <code>VAULT_TOKEN</code>,<code>VAULT_USERNAME</code>,<code>VAULT_PASSWORD</code>,<code>VAULT_ROLE_ID</code>,<code>VAULT_SECRET_ID</code>. This makes the secret_inside_kapitan file accessible throughout the inventory, where we can use the secret whenever necessary like <code>?{vaultkv:path/to/secret_inside_kapitan}</code></li> </ul> <p>Following is the example file having a secret and pointing to the vault <code>?{vaultkv:path/to/secret_inside_kapitan}</code></p> <pre><code>parameters:\n  releases:\n    cod: latest\n  cod:\n    image: alledm/cod:${cod:release}\n    release: ${releases:cod}\n    replicas: ${replicas}\n    args:\n      - --verbose=${verbose}\n      - --password=?{vaultkv:path/to/secret_inside_kapitan}\n</code></pre> <p>when <code>?{vaultkv:path/to/secret_inside_kapitan}</code> is compiled, it will look same with an 8 character prefix of sha256 hash added at the end like:</p> <pre><code>kind: Deployment\nmetadata:\n  name: cod\n  namespace: dev-sea\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: cod\n    spec:\n      containers:\n        - args:\n            - --verbose=True\n            - --password=?{vaultkv:path/to/secret_inside_kapitan:57d6f9b7}\n          image: alledm/cod:v2.0.0\n          name: cod\n</code></pre> <p>Only the user with the required tokens/permissions can reveal the secrets. Please note that the roles and permissions will be handled at the Vault level. We need not worry about it within Kapitan. Use the following command to reveal the secrets:</p> <pre><code>kapitan refs --reveal -f compile/file/containing/secret\n</code></pre> <p>Following is the result of the cod-deployment.md file after Kapitan reveal.</p> <pre><code>kind: Deployment\nmetadata:\n  name: cod\n  namespace: dev-sea\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: cod\n    spec:\n      containers:\n        - args:\n            - --verbose=True\n            - --password=batman\n          image: alledm/cod:v2.0.0\n          name: cod\n</code></pre>"},{"location":"kap_proposals/kap_6_hashicorp_vault/#dependencies","title":"Dependencies","text":"<ul> <li>hvac is a python client for Hashicorp Vault</li> </ul>"},{"location":"kap_proposals/kap_7_remote_inventory/","title":"Remote Inventory Federation","text":"<p>This feature would add the ability to Kapitan to fetch parts of the inventory from remote locations (https/git). This would allow users to combine different inventories from different sources and build modular infrastructure reusable across various repos.</p> <p>Author: @alpharoy14</p>"},{"location":"kap_proposals/kap_7_remote_inventory/#specification","title":"Specification","text":"<p>The configuration and declaration of remote inventories would be done in the inventory files.</p> <p>The file specifications are as follows:</p> <pre><code>parameters:\n kapitan:\n  inventory:\n   - type: &lt;inventory_type&gt; #git\\https\n     source: &lt;source_of_inventory&gt;\n     output_path: &lt;relative_output_path&gt;\n</code></pre> <p>On executing the <code>$ kapitan compile --fetch</code> command, first the remote inventories will be fetched followed by fetching of external dependencies and finally merge the inventory to compile.</p>"},{"location":"kap_proposals/kap_7_remote_inventory/#copying-inventory-files-to-the-output-location","title":"Copying inventory files to the output location","text":"<p>The output path is the path to save the inventory items into. The path is relative to the <code>inventory/</code> directory. For example, it could be <code>/classes/</code>. The contents of the fetched inventory will be recursively copied.</p> <p>The fetched inventory files will be cached in the <code>.dependency_cache</code> directory if <code>--cache</code> is set. eg. <code>$ kapitan compile --fetch --cache</code></p>"},{"location":"kap_proposals/kap_7_remote_inventory/#force-fetching","title":"Force fetching","text":"<p>While fetching, the output path will be recursively checked to see if it contains any file with the same name. If so, kapitan will skip fetching it.</p> <p>To overwrite the files with the newly downloaded inventory items, we can add the <code>--force-fetch</code> flag to the compile command, as shown below.</p> <p><code>$ kapitan compile --force-fetch</code></p>"},{"location":"kap_proposals/kap_7_remote_inventory/#url-type","title":"URL type","text":"<p>The URL type can be either git or http(s). Depending on the URL type, the configuration file may have additional arguments.</p> <p>E.g Git type may also include aditional <code>ref</code> parameter as illustrated below:</p> <pre><code>inventory:\n - type: git #git\\https\n   source: &lt;source_of_inventory&gt;\n   output_path: &lt;output_path&gt;\n   ref: &lt;commit_hash/branch/tag&gt;\n</code></pre>"},{"location":"kap_proposals/kap_7_remote_inventory/#implementation-details","title":"Implementation details","text":"<p>TODO</p>"},{"location":"kap_proposals/kap_7_remote_inventory/#dependencies","title":"Dependencies","text":"<ul> <li>GitPython module (and git executable) for git type</li> <li>requests module for http[s]</li> </ul>"},{"location":"kap_proposals/kap_8_google_secret_management/","title":"Support for Google Secret Manager","text":"<p>This feature will enable users to retrieve secrets from Google Secret Manager API using the <code>gsm</code> keyword.</p>"},{"location":"kap_proposals/kap_8_google_secret_management/#specification","title":"Specification","text":"<p><code>project_id</code> uniquely identifies GCP projects, and it needs to be made accessible to kapitan in one of the following ways:</p> <ul> <li>As a part of target</li> </ul> <pre><code>parameters:\n  kapitan:\n    secrets:\n      gsm:\n        project_id: Project_Id\n</code></pre> <ul> <li>As a flag</li> </ul> <pre><code>kapitan refs --google-project-id=&lt;Project_Id&gt; --write gsm:/path/to/secret_id -f secret_id_file.txt\n</code></pre> <ul> <li>As an environment variable</li> </ul> <pre><code>export PROJECT_ID=&lt;Project_Id&gt;\n</code></pre>"},{"location":"kap_proposals/kap_8_google_secret_management/#using-a-secret","title":"Using a secret","text":"<p>In GCP, a secret contains one or more secret versions, along with its metadata. The actual contents of a secret are stored in a secret version. Each secret is identified by a name. We call that variable <code>secret_id</code> e.g. my_treasured_secret. The URI of the secret becomes <code>projects/&lt;Project_Id&gt;/secrets/my_treasured_secret</code></p> <p>The following command will be used to add a <code>secret_id</code> to kapitan.</p> <pre><code>echo \"my_treasured_secret\"  | kapitan refs --write gsm:path/to/secret_inside_kapitan -t &lt;target_name&gt; -f -\n</code></pre> <p>The <code>-t &lt;target_name&gt;</code> is used to get the information about Project_ID.</p> <p>The <code>secret_id</code> is Base64 encoded and stored in <code>path/to/secret_inside_kapitan</code> as</p> <pre><code>data: bXlfdHJlYXN1cmVkX3NlY3JldAo=\nencoding: original\ntype: gsm\ngsm_params:\n  project_id: Project_ID\n</code></pre>"},{"location":"kap_proposals/kap_8_google_secret_management/#referencing-a-secret","title":"referencing a secret","text":"<p>Secrets can be refered using <code>?{gsm:path/to/secret_id:version_id}</code> e.g.</p> <pre><code>parameter:\n    mysql:\n        storage: 10G\n        storage_class: standard\n        image: mysql:latest\n        users:\n            root:\n                password: ?{gsm:path/to/secret_id:version_id}\n</code></pre> <p>Here, <code>version_id</code> will be an optional argument. By default it will point to <code>latest</code>.</p>"},{"location":"kap_proposals/kap_8_google_secret_management/#revealing-a-secret","title":"Revealing a secret","text":"<p>After compilation, the secret reference will be postfixed with 8 characters from the sha256 hash of the retrieved password</p> <pre><code>apiVersion: v1\ndata:\n  MYSQL_ROOT_PASSWORD: ?{gsm:path/to/secret_id:version_id:deadbeef}\nkind: Secret\nmetadata:\n  labels:\n    name: example-mysql\n  name: example-mysql\n  namespace: minikube-mysql\ntype: Opaque\n</code></pre> <p>To reveal the secret, the following command will be used <code>$ kapitan ref --reveal -f compiled/file/containing/secret</code></p>"},{"location":"kap_proposals/kap_8_google_secret_management/#dependencies","title":"Dependencies","text":"<ul> <li>google-cloud-secret-manager</li> </ul> <p>note Kapitan will not be responsible for authentication or access management to GCP</p>"},{"location":"kap_proposals/kap_8_modularize_kapitan/","title":"Modularize Kapitan","text":"<p>Kapitan is packaged in PYPI and as a binary along with all its dependencies. Adding an extra key/security backend means that we need to ship another dependency with that PYPI package, making deploying changes more complicated. This project would modularize kapitan into core dependencies and extra modules.</p>"},{"location":"kap_proposals/kap_8_modularize_kapitan/#usage","title":"Usage","text":"<pre><code>pip3 install --user kapitan # to install only core dependencies\nPip3 install --user kapitan[gkms] \u200b# gkms is the module\n</code></pre>"},{"location":"kap_proposals/kap_8_modularize_kapitan/#implementation","title":"Implementation","text":"<ul> <li>The main module includes the essential kapitan dependencies and reclass dependencies, which will be included in the \u200brequirement.txt\u200b file.</li> <li>The extra module pypi extras will be defined in the <code>s\u200betup.py</code>\u200b file.</li> <li>The extra dependencies are of secret backends like (AWS Key backend, Google KMS Key backend, Vault Key backend etc.) and Helm support.</li> </ul>"},{"location":"kap_proposals/kap_9_bring_your_own_helm/","title":"Bring Your Own Helm Proposal","text":""},{"location":"kap_proposals/kap_9_bring_your_own_helm/#the-problem","title":"The Problem","text":"<p>Currently the helm binding can't be run on Mac OSX. Attempts to fix this have been made on several occasions:</p> <ul> <li>https://github.com/kapicorp/kapitan/pull/414</li> <li>https://github.com/kapicorp/kapitan/pull/547</li> <li>https://github.com/kapicorp/kapitan/pull/568</li> </ul> <p>There are some issues with the current bindings besides the lack of Mac OSX support. The golang runtime (1.14) selected will effect older versions helm templates: https://github.com/helm/helm/issues/7711. Users can't select the version of helm they'd like to use for templating.</p>"},{"location":"kap_proposals/kap_9_bring_your_own_helm/#solution","title":"Solution","text":"<p>Users supply their own helm binary. This allows them to control the version of golang runtime and version of helm they'd like to use.</p> <p>In Kapitan we could rewrite the interface to use subprocess and perform commands. The cli of helm 2 vs helm 3 is slightly different but shouldn't be difficult to codify.</p> <p>This would be great to get rid of cffi and golang which will reduce complexity and build time of the project.</p> <p>Depending on how this goes, this could pave the way for a \"bring your own binary\" input type.</p>"},{"location":"pages/external_dependencies/","title":"External dependencies","text":"<p>Kapitan has the functionality to fetch external dependencies from remote locations. </p> <p>Supported dependencies types are:</p> <ul> <li>git</li> <li>http</li> <li>helm</li> </ul>"},{"location":"pages/external_dependencies/#usage","title":"Usage","text":"<p>Kapitan by default will not attempt to download any dependency, and rely on what is already available.</p>"},{"location":"pages/external_dependencies/#basic-fetching","title":"Basic fetching","text":"<p>You can use the <code>fetch</code> option to explicitly fetch the dependencies:</p> clidotfile <pre><code>kapitan compile --fetch\n</code></pre> <p><code>.kapitan</code></p> <p>to make it default, then simply use <code>kapitan compile</code></p> <pre><code>...\ncompile:\n  fetch: true \n</code></pre> <p>This will download the dependencies and store them at their respective <code>output_path</code>.</p>"},{"location":"pages/external_dependencies/#overwrite-local-changes","title":"Overwrite local changes","text":"<p>When fetching a dependency, Kapitan will refuse to overwrite existing files to preserve your local modifications. </p> <p>Use the <code>force-fetch</code> option to force overwrite your local files in the <code>output_path</code>.</p> clidotfile <pre><code>kapitan compile --force-fetch\n</code></pre> <p><code>.kapitan</code></p> <p>to make it default, then simply use <code>kapitan compile</code></p> <pre><code>...\ncompile:\n  force-fetch: true \n</code></pre>"},{"location":"pages/external_dependencies/#caching","title":"Caching","text":"<p>Kapitan also supports caching Use the <code>--cache</code> flag to cache the fetched items in the <code>.dependency_cache</code> directory in the root project directory.</p> <pre><code>```shell\nkapitan compile --cache --fetch\n```\n</code></pre>"},{"location":"pages/external_dependencies/#defining-dependencies","title":"Defining dependencies","text":"githttphelm"},{"location":"pages/external_dependencies/#syntax","title":"Syntax","text":"<pre><code>parameters:\n  kapitan:\n    dependencies:\n    - type: git\n      output_path: path/to/dir\n      source: git_url # mkdocs (1)!\n      subdir: relative/path/from/repo/root (optional) # mkdocs (2)!\n      ref: tag, commit, branch etc. (optional) # mkdocs (3)!\n      submodules: true/false (optional) # mkdocs (4)!\n</code></pre> <ol> <li>Git types can fetch external <code>git</code> repositories through either HTTP/HTTPS or SSH URLs. </li> <li>Optional supports for cloning just a sub-directory</li> <li>Optional support for accessing them in specific commits and branches (refs).</li> <li>Optional support to disable fetching the submodules of a repo.</li> </ol> <p>Note</p> <p>This type depends on the <code>git</code> binary installed on your system and available to Kapitan.</p>"},{"location":"pages/external_dependencies/#example","title":"Example","text":"<p>Say we want to fetch the source code from our kapitan repository, specifically, <code>kapicorp/kapitan/kapitan/version.py</code>. Let's create a very simple target file <code>inventory/targets/kapitan-example.yml</code>.</p> <pre><code>parameters:\n  kapitan:\n    vars:\n      target: kapitan-example\n    dependencies:\n    - type: git\n      output_path: source/kapitan\n      source: git@github.com:kapicorp/kapitan.git\n      subdir: kapitan\n      ref: master\n      submodules: true\n    compile:\n    - input_paths:\n      - source/kapitan/version.py\n      input_type: jinja2 # just to copy the file over to target\n      output_path: .\n</code></pre>"},{"location":"pages/external_dependencies/#syntax_1","title":"Syntax","text":"<pre><code>parameters:\n  kapitan:\n    dependencies:\n    - type: http | https # mkdocs (2)!\n      output_path: path/to/file # mkdocs (1)!\n      source: http[s]://&lt;url&gt; # mkdocs (2)!\n      unpack: True | False # mkdocs (3)! \n</code></pre> <ol> <li><code>output_path</code> must fully specify the file name. For example:</li> <li>http[s] types can fetch external dependencies available at <code>http://</code> or <code>https://</code> URL.</li> <li>archive mode: download and unpack</li> </ol>"},{"location":"pages/external_dependencies/#example_1","title":"Example","text":"Single fileArchive <p>Say we want to download kapitan README.md file. Since it's on Github, we can access it as https://raw.githubusercontent.com/kapicorp/kapitan/master/README.md. Using the following inventory, we can copy this to our target folder:</p> <pre><code>parameters:\n  kapitan:\n    vars:\n      target: kapitan-example\n    dependencies:\n    - type: https\n      output_path: README.md\n      source: https://raw.githubusercontent.com/kapicorp/kapitan/master/README.md\n    compile:\n    - input_paths:\n      - README.md\n      input_type: jinja2\n      output_path: .\n</code></pre>"},{"location":"pages/external_dependencies/#syntax_2","title":"Syntax","text":"<pre><code>parameters:\n  kapitan:\n    dependencies:\n    - type: helm\n      output_path: path/to/chart\n      source: http[s]|oci://&lt;helm_chart_repository_url&gt;\n      version: &lt;specific chart version&gt;\n      chart_name: &lt;name of chart&gt;\n      helm_path: &lt;helm binary&gt;\n</code></pre> <p>Fetches helm charts and any specific subcharts in the <code>requirements.yaml</code> file.</p> <p><code>helm_path</code> can be used to specify where the <code>helm</code> binary name or path. It defaults to the value of the <code>KAPITAN_HELM_PATH</code> environment var or simply to <code>helm</code> if neither is set. You should specify only if you don't want the default behavior.</p> <p><code>source</code> can be either the URL to a chart repository, or the URL to a chart on an OCI registry (supported since Helm 3.8.0).</p>"},{"location":"pages/external_dependencies/#example_2","title":"Example","text":"<p>If we want to download the prometheus helm chart we simply add the dependency to the monitoring target. We want a specific version <code>11.3.0</code> so we put that in.</p> <pre><code>parameters:\n  kapitan:\n    vars:\n      target: monitoring\n    dependencies:\n      - type: helm\n        output_path: charts/prometheus\n        source: https://kubernetes-charts.storage.googleapis.com\n        version: 11.3.0\n        chart_name: prometheus\n    compile:\n      - input_type: helm\n        output_path: .\n        input_paths:\n          - charts/prometheus\n        helm_values:\n        alertmanager:\n            enabled: false\n        helm_params:\n          namespace: monitoring\n          name: prometheus\n</code></pre>"},{"location":"pages/kapitan_overview/","title":"Kapitan Overview","text":""},{"location":"pages/kapitan_overview/#kapitan-at-a-glance","title":"Kapitan at a glance","text":"<p>Kapitan is a powerful configuration management tool designed to help engineers manage complex systems through code. It centralizes and simplifies the management of configurations with a structured approach that revolves around a few core concepts. </p> Kapitan diagram <pre><code>%%{ init: { securityLevel: 'loose'} }%%\ngraph LR\n    classDef pink fill:#f9f,stroke:#333,stroke-width:4px,color:#000,font-weight: bold;\n    classDef blue fill:#00FFFF,stroke:#333,stroke-width:4px,color:#000,font-weight: bold;\n    TARGET1 --&gt; KAPITAN\n    TARGET2 --&gt; KAPITAN\n    TARGETN --&gt; KAPITAN\n    KAPITAN --&gt; EXTERNAL\n    KAPITAN --&gt; GENERATORS\n    KAPITAN --&gt; HELM\n    KAPITAN --&gt; JINJA\n    KAPITAN --&gt; JSONNET\n    KAPITAN --&gt; KADET\n    EXTERNAL --&gt; OUTPUT\n    GENERATORS --&gt; OUTPUT\n    JINJA --&gt; OUTPUT\n    JSONNET --&gt; OUTPUT\n    KADET --&gt; OUTPUT\n    HELM --&gt; OUTPUT\n    GKMS --&gt; REFERENCES\n    AWSKMS --&gt; REFERENCES\n    VAULT --&gt; REFERENCES\n    OTHER --&gt; REFERENCES\n    PLAIN --&gt; REFERENCES\n    OUTPUT --&gt; TARGETN_OUTPUT\n    OUTPUT --&gt; TARGET1_OUTPUT \n    OUTPUT --&gt; TARGET2_OUTPUT \n    REFERENCES --&gt; KAPITAN\n    TARGET1_OUTPUT --&gt; DOCUMENTATION \n    TARGET1_OUTPUT --&gt; KUBERNETES\n    TARGET1_OUTPUT --&gt; SCRIPTS \n    TARGET1_OUTPUT --&gt; TERRAFORM\n    CLASSES --&gt; TARGET1\n    CLASSES --&gt; TARGET2\n    CLASSES --&gt; TARGETN\n\n    subgraph \"Inventory\"\n        CLASSES[classes]\n        TARGET1([\"target 1\"]):::pink\n        TARGET2([\"target 2\"])\n        TARGETN([\"target N\"])\n    end\n\n    subgraph \"references\"\n        direction TB\n        GKMS[\"GCP KMS\"]\n        AWSKMS[\"AWS KMS\"]\n        VAULT[\"Hashicorp Vault\"]\n        OTHER[\"others\"]\n        PLAIN[\"plain\"]\n        REFERENCES[\"references\"]\n    end\n\n    KAPITAN((\"&lt;img src='/images/kapitan_logo.png'; width='80'/&gt;\")):::blue\n    click EXTERNAL \"/compile#external\"\n\n    subgraph \"Input Types\" \n        EXTERNAL[\"external\"]\n        GENERATORS[\"generators\"]\n        HELM[\"helm\"]\n        JINJA[\"jinja\"]\n        JSONNET[\"jsonnet\"]\n        KADET[\"kadet\"]\n    end\n\n    OUTPUT{{\"compiled output\"}}:::blue\n\n\n\n    subgraph \" \"\n        TARGET1_OUTPUT([target1]):::pink\n        DOCUMENTATION[\"docs\"]\n        KUBERNETES[\"manifests\"]\n        SCRIPTS[\"scripts\"]\n        TERRAFORM[\"terraform\"]\n    end\n\n    TARGET2_OUTPUT([\"target 2\"])\n    TARGETN_OUTPUT([\"target N\"])\n</code></pre> <p>Let's explore these concepts in a way that's accessible to new users:</p>"},{"location":"pages/kapitan_overview/#inventory","title":"Inventory","text":"<p>At the core of Kapitan lies the Inventory, a structured database of variables meticulously organized in YAML files.  This hierarchical setup serves as the single source of truth (SSOT) for your system's configurations, making it easier to manage and reference the essential components of your infrastructure. Whether you're dealing with Kubernetes configurations, Terraform resources, or even business logic, the Inventory allows you to define and store these elements efficiently. This central repository then feeds into Kapitan's templating engines, enabling seamless reuse across various applications and services.</p>"},{"location":"pages/kapitan_overview/#input-types","title":"Input Types","text":"<p>Kapitan takes the information stored in the Inventory and brings it to life through its templating engines upon compilation. This process transforms static data into dynamic configurations, capable of generating a wide array of outputs like Kubernetes manifests, Terraform plans, documentation, and scripts. It's about making your configurations work for you, tailored to the specific needs of your projects.</p> <p>See Input Types for more</p>"},{"location":"pages/kapitan_overview/#generators","title":"Generators","text":"<p>Generators offer a straightforward entry point into using Kapitan, requiring minimal to no coding experience. These are essentially pre-made templates that allow you to generate common configuration files, such as Kubernetes manifests, directly from your Inventory data. Kapitan provides a wealth of resources, including the Kapitan Reference GitHub repository and various blog posts, to help users get up and running with generators.</p>"},{"location":"pages/kapitan_overview/#kadet","title":"Kadet","text":"<p>For those looking to leverage the full power of Kapitan, Kadet introduces a method to define and reuse complex configurations through Python. This internal library facilitates the creation of JSON and YAML manifests programmatically, offering a higher degree of customization and reuse. Kadet empowers users to craft intricate configurations with the simplicity and flexibility of Python.</p>"},{"location":"pages/kapitan_overview/#references","title":"References","text":"<p>Kapitan References provide a secure way to store passwords, settings, and other essential data within your project. Think of them as special code placeholders.</p> <ul> <li>Flexibility: Update a password once, and Kapitan updates it everywhere automatically.</li> <li>Organization: References tidy up your project, especially when you're juggling multiple settings or environments (dev, staging, production). Security: Protect sensitive information like passwords with encryption</li> </ul> <p>Tip</p> <p>Use Tesoro, our Kubernetes Admission Controller, to complete your integration with Kubernetes for secure secret decryption on-the-fly.</p>"},{"location":"pages/remote_repositories/","title":"Remote Inventories","text":"<p>Kapitan is capable of recursively fetching inventory items stored in remote locations and copy it to the specified output path. This feature can be used by specifying those inventory items in classes or targets under <code>parameters.kapitan.inventory</code>. Supported types are:</p> <ul> <li>git type</li> <li>http type</li> </ul> <p>Class items can be specified before they are locally available as long as they are fetched in the same run. Example of this is given below.</p>"},{"location":"pages/remote_repositories/#git-type","title":"Git type","text":"<p>Git types can fetch external inventories available via HTTP/HTTPS or SSH URLs. This is useful for fetching repositories or their sub-directories, as well as accessing them in specific commits and branches (refs).</p> <p>Note: git types require git binary on your system.</p>"},{"location":"pages/remote_repositories/#definition","title":"Definition","text":"<pre><code>parameters:\n  kapitan:\n    inventory:\n    - type: git\n      output_path: path/to/dir\n      source: git_url\n      subdir: relative/path/from/repo/root (optional)\n      ref: tag, commit, branch etc. (optional)\n</code></pre>"},{"location":"pages/remote_repositories/#example","title":"Example","text":"<p>Lets say we want to fetch a class from our kapitan repository, specifically <code>kapicorp/kapitan/tree/master/examples/docker/inventory/classes/dockerfiles.yml</code>. </p> <p>Lets create a simple target file <code>docker.yml</code></p> <p>Note</p> <p>external dependencies are used to fetch dependency items in this example.</p> <p><code>targets/docker.yml</code></p> <pre><code>classes:\n  - dockerfiles\nparameters:\n  kapitan:\n    vars:\n      target: docker\n    inventory:\n      - type: git\n        source: https://github.com/kapicorp/kapitan\n        subdir: examples/docker/inventory/classes/\n        output_path: classes/\n    dependencies:\n      - type: git\n        source: https://github.com/kapicorp/kapitan\n        subdir: examples/docker/components\n        output_path: components/\n      - type: git\n        source: https://github.com/kapicorp/kapitan\n        subdir: examples/docker/templates\n        output_path: templates/\n  dockerfiles:\n  - name: web\n    image: amazoncorretto:11\n  - name: worker\n    image: amazoncorretto:8\n</code></pre> <pre><code>kapitan compile --fetch\n</code></pre> click to expand output <pre><code>[WARNING] Reclass class not found: 'dockerfiles'. Skipped!\n[WARNING] Reclass class not found: 'dockerfiles'. Skipped!\nInventory https://github.com/kapicorp/kapitan: fetching now\nInventory https://github.com/kapicorp/kapitan: successfully fetched\nInventory https://github.com/kapicorp/kapitan: saved to inventory/classes\nDependency https://github.com/kapicorp/kapitan: saved to components\nDependency https://github.com/kapicorp/kapitan: saved to templates\nCompiled docker (0.11s)\n</code></pre>"},{"location":"pages/remote_repositories/#http-type","title":"http type","text":"<p><code>http[s]</code> types can fetch external inventories available at <code>http://</code> or <code>https://</code> URL.</p>"},{"location":"pages/remote_repositories/#definition_1","title":"Definition","text":"<pre><code>parameters:\n  kapitan:\n    inventory:\n    - type: http | https\n      output_path: full/path/to/file.yml\n      source: http[s]://&lt;url&gt;\n      unpack: True | False # False by default\n</code></pre>"},{"location":"pages/remote_repositories/#example_1","title":"Example","text":"<p><code>targets/mysql-generator-fetch.yml</code></p> <pre><code>classes:\n  - common\n  - kapitan.generators.kubernetes\nparameters:\n  kapitan:\n    inventory:\n      - type: https\n        source: https://raw.githubusercontent.com/kapicorp/kapitan-reference/master/inventory/classes/kapitan/generators/kubernetes.yml\n        output_path: classes/kapitan/generators/kubernetes.yml\n  components:\n    mysql:\n      image: mysql\n</code></pre> <pre><code>kapitan compile --fetch\n</code></pre> click to expand output <pre><code>./kapitan compile -t mysql-generator-fetch --fetch\nInventory https://raw.githubusercontent.com/kapicorp/kapitan-reference/master/inventory/classes/kapitan/generators/kubernetes.yml: fetching now\nInventory https://raw.githubusercontent.com/kapicorp/kapitan-reference/master/inventory/classes/kapitan/generators/kubernetes.yml: successfully fetched\nInventory https://raw.githubusercontent.com/kapicorp/kapitan-reference/master/inventory/classes/kapitan/generators/kubernetes.yml: saved to inventory/classes/kapitan/generators/kubernetes.yml\n\n...\ncut\n...\n\nCompiled mysql-generator-fetch (0.06s)\n</code></pre>"},{"location":"pages/blog/","title":"Blog","text":""},{"location":"pages/blog/04/12/2022/kapitan-logo-5-years-of-kapitan/","title":"5 Years of Kapitan","text":"<p>Last October we quietly celebrated 5 years of Kapitan. </p> <p>In 5 years, we've been able to witness a steady and relentless of Kapitan, which has however never caught the full attention of the majority of the community.</p> <p>The main issue has always been around an embarassing lack of documentation, and we've worked hard to improve on that, with more updates due soon.</p> <p>Let this first blog post from a revamped website be a promise to our community of a better effort in explaining what sets Kapitan apart, and makes it the only tool of its kind. </p> <p>And let's start with a simple question: Why do you even need Kapitan?</p> <p> Credits  </p> <pre><code>In reality Kapitan's heatbeat started about 9 months earlier at DeepMind Health, created by [**Ricardo Amaro**](https://github.com/ramaro) with the help of some of my amazing team: in no particular order [Adrian Chifor](https://github.com/adrianchifor), [Paul S](https://github.com/uberspot) and [Luis Buriola](https://github.com/gburiola). It was then kindly released to the community by Google/DeepMind and is has so been improved thanks to more than [50 contributors](https://github.com/kapicorp/kapitan/graphs/contributors).\n</code></pre>"},{"location":"pages/blog/04/12/2022/kapitan-logo-5-years-of-kapitan/#why-do-i-need-kapitan","title":"Why do I need Kapitan?","text":"<p>Kapitan is a hard sell, but a rewarding one. For these main reasons:</p> <ol> <li>Kapitan solves problems that some don\u2019t know/think to have.</li> <li>Some people by now have probably accepted the Status Quo and think that some suffering is part of their job descriptions.</li> <li>Objectively, Kapitan requires an investment of effort to learn how to use a new tool, and this adds friction.</li> </ol> <p>All I can say it is very rewarding once you get to use it, so stick with me while I try to explain the problems that Kapitan is solving</p>"},{"location":"pages/blog/04/12/2022/kapitan-logo-5-years-of-kapitan/#the-problems","title":"The problems","text":"<p>It would be reductive to list the problems that Kapitan solves, because sometimes we ourselves are stunned by what Kapitan is being used for, so I will start with some common relatable ones, and perhaps that will give you the right framing to understand how to use it with your setup.</p> <p>In its most basic explanation, Kapitan solves the problem of avoiding duplication of configuration data: by consolidating it in one place (the Inventory), and making it accessible by all the tools and languages it integrates with (see Input Types). </p> <p>This configuration data is then used by Kapitan (templates) to configure and operate a number of completely distinct and unaware tools which would normally not be able to share their configurations.</p>"},{"location":"pages/blog/04/12/2022/kapitan-logo-5-years-of-kapitan/#without-kapitan","title":"Without Kapitan","text":"<p>Let's consider the case where you want to define a new bucket, with a given <code>bucket_name</code>. Without Kapitan you would probably need to:</p> <ul> <li>Write a PR on your Terraform repository to create the new bucket.</li> <li>Which name should I use? Make sure to write it down! <code>CTRL-C</code></li> <li>Write a PR for your <code>values.yaml</code> file to configure your Helm chart: <code>&lt;CTRL-V&gt;</code></li> <li>Write somewhere some documentation to write down the bucket name and why it exists. Another <code>&lt;CTRL-V&gt;</code></li> <li>Another PR to change some <code>**kustomize**</code> configuration for another service to tell it to use the new bucket <code>&lt;CTRL-V&gt;</code></li> <li>Days after, time to upload something to that bucket: <code>gsutil cp my_file wait_what_was_the_bucket_name_again</code>.. Better check the documentation: <code>CTRL-C</code> + <code>&lt;CTRL-V&gt;</code></li> </ul>"},{"location":"pages/blog/04/12/2022/kapitan-logo-5-years-of-kapitan/#with-kapitan","title":"With Kapitan","text":"<p>When using Kapitan, your changes are likely to be contained within one PR, from which you can have a full view of everything that is happening. What happens is explained in this flow</p> <pre><code>\n%%{ init: { securityLevel: 'loose'} }%%\ngraph LR\n    classDef pink fill:#f9f,stroke:#333,stroke-width:4px,color:#000,font-weight: bold;\n    classDef blue fill:#00FFFF,stroke:#333,stroke-width:4px,color:#000,font-weight: bold;\n    classDef bold color:#000,font-weight: bold;\n\n    DATA --&gt; KAPITAN\n    BUCKET --&gt; DATA\n    KAPITAN --&gt; KUBERNETES\n    KAPITAN --&gt; TERRAFORM\n    KAPITAN --&gt; DOCUMENTATION\n    KAPITAN --&gt; SCRIPT\n    KAPITAN --&gt; HELM\n    KUBERNETES --&gt;  BUCKET_K8S\n    TERRAFORM --&gt;  BUCKET_TF\n    DOCUMENTATION  --&gt; BUCKET_DOC\n    SCRIPT --&gt; BUCKET_SCRIPT\n    HELM --&gt; BUCKET_HELM\n\n\n    DATA[(\"All your data\")]\n    BUCKET(\"bucket_name\")\n    KAPITAN((\"&lt;img src='/images/kapitan_logo.png'; width='150'/&gt;\")):::blue\n\n\n    subgraph \" \"\n      KUBERNETES([\"Kubernetes\"]):::pink\n      BUCKET_K8S(\".. a ConfigMap uses bucket_name\"):::bold\n    end\n    subgraph \" \"\n    TERRAFORM([\"Terraform\"]):::pink\n    BUCKET_TF(\"..creates the bucket bucket_name\"):::bold\n    end\n    subgraph \" \"\n    DOCUMENTATION([\"Documentation\"]):::pink\n    BUCKET_DOC(\"..references a link to bucket_name\"):::bold\n    end\n    subgraph \" \"\n    SCRIPT([\"Canned Script\"]):::pink\n    BUCKET_SCRIPT(\"..knows how to upload files to bucket_name\"):::bold\n    end\n    subgraph \" \"\n    HELM([\"Helm\"]):::pink\n    BUCKET_HELM(\"..configures a chart to use the bucket_name\"):::bold\n    end</code></pre> <p>Thanks to its flexiblility, you can use Kapitan to generate all sorts of configurations: Kubernetes and Terraform resources, ArgoCD pipelines, Docker Compose files, random configs, scripts, documentations and anything else you find relevant.  The trick is obviously on how to drive these changes, but it is not as complicated as it sounds. We'll get there soon enough!</p> <p>Let's see now another example of things that are so established in the way to do things that become elusivly impossible to see. As a way to highlight the potential issues with this way of doing things, let's ask some questions on your current setup. We pick on Kubernetes this time.</p>"},{"location":"pages/blog/04/12/2022/kapitan-logo-5-years-of-kapitan/#kubernetes","title":"Kubernetes","text":"<p>I\u2019ll start with Kubernetes, such a popular and brilliant solution to problems most people should not be concerned with (jokes apart, I adore Kubernetes).  To most, Kubernetes is that type of solution that quickly turns into a problem of its own right.</p> <p>So.. how do you deploy to Kubernetes right now?</p> <p>Helm comes to mind first, right? </p> <p> Kapitan + Helm: BFF </p> <p>In spite of Kapitan being initially considered (even by ourselves) as an alternative to Helm, we\u2019ve actually enjoyed the benefits of integrating with this amazing tool and the ecosystem it gives us access to. So yes, good news: you can use Helm right from within Kapitan!.  </p> <p>Well, let\u2019s put that to a test. How do you manage your Helm charts? I\u2019ll attempt to break these questions down into categories.</p> Code OrganizationDRYMaintenanceOperationsDocumentationSecrets managementEverything else <ul> <li>Where do you keep your Helm charts? <ul> <li>In a single repository?</li> <li>How many repositories?</li> <li>Alongside the code you develop?</li> </ul> </li> <li>What about the official ones that you didn't create yourself?</li> </ul> <ul> <li>How many <code>values.yaml</code> files do you have?</li> <li>How much consistency is there between them? any snowflakes?</li> <li>If you change something, like with the <code>bucket_name</code> example above:<ul> <li>how many places do you need to go and update? </li> <li>And how many times do you get it wrong?</li> </ul> </li> <li>Don't you feel all your charts look the same? <ul> <li>Yet how many times do you need to deviate from the one you thought captured everything? </li> <li>What if you need to make a change to all your charts at once: how do you deal with it?</li> </ul> </li> <li>What about configuration files, how do you deal with templating those?</li> </ul> <ul> <li>How do you deal with \u201cofficial\u201d charts, do they always cover what you want to do? </li> <li>How do you deal with modifications that you need to apply to your own version of a an official chart?</li> <li>What if you need to make a change that affects ALL your charts?</li> <li>Or if the change is for all the charts for a set of microservices?</li> </ul> <ul> <li>How many times you find yourself seting parameters on the command line of Helm and other tools?</li> <li>How many times did you connect to the wrong context in Kubernetes</li> <li>How many of your colleagues have the same clean context setup as you have?</li> <li>How many things are there that you wish you were tracking?</li> <li>How do I connect to the production database? Which user is it again?</li> <li>How easy is it for you to create a new environment from scratch? <ul> <li>Are you sure? </li> <li>When was the last time you tried?</li> </ul> </li> </ul> <ul> <li>How easy is it to keep your configuration up to date?</li> <li>Does your documentation need to be \u201cunderstood\u201d or can be just executed on?<ul> <li>How many conditionals like this do you have in your documentation?  <p>NOTE: Cluster X in project Y has an older version of Q and requires you to do Z instead N because of A, B and C!</p> </li> </ul> </li> <li>Would you be able to follow those instructions at 3am on a Sunday morning?</li> </ul> <ul> <li>How do you handle secrets in your repository? </li> <li>Do you know how to create your secrets from scratch? </li> <li>Do you remember that token you created 4 months ago? How did you do that?</li> <li>How long would it take you? </li> <li>Is the process of creating them \u201csecure\u201d? <ul> <li>Or does it leave you with random certificates and tokens unencrypted on your \u201cDownloads\u201d folder?</li> </ul> </li> </ul> <ul> <li>The above concerns: do they also apply to other things you manage? </li> <li>Terraform? </li> <li>Pipelines? </li> <li>Random other systems you interact with?</li> </ul> <p>I\u2019ll stop here because I do not want to lose you, and neither do I want to discourage you. </p> <p>But if you look around it\u2019s true, you do have a very complicated setup. And Kapitan can help you streamline it for you. In fact, Kapitan can leave you with a consistent and uniform way to manage all these concerns at once.</p> <p>My job here is done: you have awakened and you won't look at your setup in the same way. Keep tuned and learn about how Kapitan can change the way you do things.</p>"},{"location":"pages/blog/04/12/2022/kapitan-logo-new-kapitan-release--v0310/","title":"New Kapitan release  v0.31.0","text":"<p>The Kapicorp team is happy to to announce a new release of Kapitan.</p> <p>This release is yet another great bundle of features and improvements over the past year, the majority of which have been contributions from our community!</p> <p>Head over our release page on GitHub for a full list of features and contributors.</p> <p>If you missed it, have a look at our latest blog post here 5 years of Kapitan</p> <p>Please help us by visiting our Sponsor Kapitan page.</p>"},{"location":"pages/blog/04/12/2022/kapitan-logo-new-kapitan-release--v0320/","title":"New Kapitan release  v0.32.0","text":"<p>The Kapicorp team is happy to to announce a new release of Kapitan.</p> <p>This release contains loads of improvements for the past 6 months, the majority of which have been contributions from our community!</p> <p>Head over our release page on GitHub for a full list of features and contributors.</p> <p>Please help us by visiting our Sponsor Kapitan page.</p>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/","title":"Deploying Keda with Kapitan","text":"<p>We have worked hard to bring out a brand new way of experience Kapitan, through something that we call generators</p> <p>Although the concept is something we've introduced in 2020 with our blog post Keep your ship together with Kapitan, the sheer amount of new capabilities (and frankly, the embarassing lack of documentation and examples) forces me to show you the new capabilities using a practicle example: deploying Keda.</p>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#objective-of-this-tutorial","title":"Objective of this tutorial","text":"<p>We are going to deploy Keda using the helm chart approach. While Kapitan supports a native way to deploy helm charts using the helm input type, we are going instead to use a generator based approach using the \"<code>charts</code>\" generator.</p> <p>This tutorial will show you how to configure kapitan to:</p> <ul> <li>download a helm chart</li> <li>compile a helm chart</li> <li>modify a helm chart using mutations</li> </ul> <p>The content of this tutorial is already available on the <code>kapitan-reference</code></p>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#deploying-keda","title":"Deploying KEDA","text":""},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#define-parameters","title":"Define parameters","text":"<pre><code>## inventory/classes/components/keda.yml\nparameters:\n  keda:\n    params:\n      # Variables to reference from other places\n      application_version: 2.11.2\n      service_account_name: keda-operator\n      chart_name: keda\n      chart_version: 2.11.2\n      chart_dir: system/sources/charts/${keda:params:chart_name}/${keda:params:chart_name}/${keda:params:chart_version}/${keda:params:application_version}\n      namespace: keda\n      helm_values: {}\n...\n</code></pre> <p>Override Helm Values</p> <p>As an example we could be passing to helm an override to the default <code>values</code> parameters to make the operator deploy 2 replicas.</p> <pre><code>  helm_values:\n    operator:\n      replicaCount: 2  \n</code></pre>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#download-the-chart","title":"Download the chart","text":"<p>Kapitan supports downloading dependencies, including helm charts.</p> <p>When Kapitan is run with the <code>--fetch</code>, it will download the dependency if not already present. Use <code>--force-fetch</code> if you want to download it every time. Learn more about External dependencies</p> <pre><code>## inventory/classes/components/keda.yml\n...\n  kapitan:\n    dependencies:\n      # Tells kapitan to download the helm chart into the chart_dir directory\n      - type: helm\n        output_path: ${keda:params:chart_dir}\n        source: https://kedacore.github.io/charts\n        version: ${keda:params:chart_version}\n        chart_name: ${keda:params:chart_name}\n...\n</code></pre> <p>Parameter interpolation</p> <p>Notice how we are using parameter interpolation from the previously defined <code>keda.params</code> section. This will make it easier in the future to override some aspects of the configuration on a per-target base.</p>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#generate-the-chart","title":"Generate the chart","text":"<pre><code>## inventory/classes/components/keda.yml\n...\n  charts:\n     # Configures a helm generator to compile files for the given chart\n    keda:\n      chart_dir: ${keda:params:chart_dir}\n      helm_params:\n        namespace: ${keda:params:namespace}\n        name: ${keda:params:chart_name}\n      helm_values: ${keda:params:helm_values}\n</code></pre>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#compile","title":"Compile","text":"<p>Before we can see any effect, we need to attach the class to a target. We will create a simple target which looks like</p> <pre><code># inventory/targets/tutorials/keda.yml\nclasses:\n- common\n- components.keda\n</code></pre> <p>Now when we run <code>kapitan compile</code> we will see the chart being donwloaded and the manifests being produced.</p> <pre><code>./kapitan compile -t keda --fetch\nDependency keda: saved to system/sources/charts/keda/keda/2.11.2/2.11.2\nRendered inventory (1.87s)\nCompiled keda (2.09s)\n</code></pre> <p><code>kapitan compile</code> breakdown</p> <ul> <li><code>--fetch</code> tells kapitan to fetch the chart if it is not found locally</li> <li><code>-t keda</code> tells kapitan to compile only the previously defined <code>keda.yml</code> target</li> </ul> <pre><code>ls -l compiled/keda/manifests/\ntotal 660\n-rw-r--r-- 1 ademaria root 659081 Aug 29 10:25 keda-bundle.yml\n-rw-r--r-- 1 ademaria root     79 Aug 29 10:25 keda-namespace.yml\n-rw-r--r-- 1 ademaria root   7092 Aug 29 10:25 keda-rbac.yml\n-rw-r--r-- 1 ademaria root   1783 Aug 29 10:25 keda-service.yml\n</code></pre>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#using-mutations","title":"Using mutations","text":"<p>Now let's do a couple of things that would not be easy to do with helm natively.</p> <p>You can already notice that the content of the chart is being splitted into multiple files: this is because the Generator is configured to separate different resources types into different files for convenience and consistency. The mechanism behing it is the \"Mutation\" of type \"bundle\" which tells Kapitan which file to save a resource into.</p> <p>Here are some example \"mutation\" which separates different <code>kinds</code> into different files</p> <pre><code>        mutations:\n          bundle:\n            - conditions:\n                kind: [Ingress]\n              filename: '{content.component_name}-ingress'\n              ...\n            - conditions:\n                kind: [HorizontalPodAutoscaler, PodDisruptionBudget, VerticalPodAutoscaler]\n              filename: '{content.component_name}-scaling'\n            - conditions:\n                kind: ['*']\n              filename: '{content.component_name}-bundle'\n</code></pre> <p>Catch-all rule</p> <p>Notice the catchall rule at the end that puts everything that has not matched into the <code>bundle.yml</code> file</p>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#bundle-mutation","title":"<code>bundle</code> mutation","text":"<p>Currently most of the keda related resources are bundled into the <code>-bundle.yml</code> file Instead, we want to separate them into their own file.</p> <p>Let's add this configuration:</p> <pre><code>  charts:\n     # Configures a helm generator to compile files for the given chart\n    keda:\n      chart_dir: ${keda:params:chart_dir}\n      ... \n      mutations:\n        bundle:\n          - conditions:\n              # CRDs need to be setup separately\n              kind: [CustomResourceDefinition]\n            filename: '{content.component_name}-crds'\n</code></pre> <p>Upon compile, you can now see that the CRD are being moved to a different file:</p> <pre><code>ls -l compiled/keda/manifests/\ntotal 664\n-rw-r--r-- 1 ademaria root  11405 Aug 29 10:56 keda-bundle.yml\n-rw-r--r-- 1 ademaria root 647672 Aug 29 10:56 keda-crds.yml\n-rw-r--r-- 1 ademaria root     79 Aug 29 10:56 keda-namespace.yml\n-rw-r--r-- 1 ademaria root   7092 Aug 29 10:56 keda-rbac.yml\n-rw-r--r-- 1 ademaria root   1783 Aug 29 10:56 keda-service.yml\n</code></pre>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#patch-mutation","title":"<code>patch</code> mutation","text":"<p>As we are using Argo, we want to pass a special <code>argocd.argoproj.io/sync-options</code> annotation to the CRD only so that ArgoCD can handle them properly.</p> <p>For this we are going to use the <code>patch</code> mutation:</p> <pre><code>...\n      mutations:\n...\n        patch:\n          - conditions:\n              kind: [CustomResourceDefinition]\n            patch:\n              metadata:\n                annotations:\n                  argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true,Replace=true\n</code></pre> <p>Upon compile, you can now see that the CRDs have been modified as required:</p> <pre><code>diff --git a/compiled/keda/manifests/keda-crds.yml b/compiled/keda/manifests/keda-crds.yml\nindex 2662bf3..9306c3a 100644\n--- a/compiled/keda/manifests/keda-crds.yml\n+++ b/compiled/keda/manifests/keda-crds.yml\n@@ -2,6 +2,7 @@ apiVersion: apiextensions.k8s.io/v1\n kind: CustomResourceDefinition\n metadata:\n   annotations:\n+    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true,Replace=true\n     controller-gen.kubebuilder.io/version: v0.12.0\n</code></pre>"},{"location":"pages/blog/27/08/2023/kapitan-logo-deploying-keda-with-kapitan/#summary","title":"Summary","text":"<p>With this tutorial have explored some capabilities of Kapitan to manage and perform changes to helm charts. Next tutorial will show how to make use of Keda and deploy a generator for Keda resources</p>"},{"location":"pages/blog/12/02/2024/kapitan-logo-new-kapitan-release--v0331/","title":"New Kapitan release  v0.33.1","text":"<p>The Kapicorp team is happy to to announce a new release of Kapitan.</p> <p>This release contains loads of improvements for the past 8 months, the majority of which have been contributions from our community!</p> <p>Head over our release page on GitHub for a full list of features and contributors.</p> <p>Please help us by visiting our Sponsor Kapitan page.</p>"},{"location":"pages/commands/kapitan_compile/","title":"CLI Reference | <code>kapitan compile</code>","text":""},{"location":"pages/commands/kapitan_compile/#kapitan-compile","title":"<code>kapitan compile</code>","text":"<p>Merges inventory and inputs and produces generated files in the output folder (<code>/compiled</code> by default)</p>"},{"location":"pages/commands/kapitan_compile/#compile-all-targets","title":"Compile all targets","text":"<pre><code>kapitan compile\n</code></pre> click to expand output <pre><code>Compiled mysql-generator-fetch (0.18s)\nCompiled vault (0.25s)\nCompiled pritunl (0.22s)\nCompiled gke-pvm-killer (0.05s)\nCompiled examples (0.30s)\nCompiled mysql (0.08s)\nCompiled postgres-proxy (0.06s)\nCompiled echo-server (0.06s)\nCompiled global (0.03s)\nCompiled guestbook-argocd (0.08s)\nCompiled tutorial (0.13s)\nCompiled kapicorp-project-123 (0.03s)\nCompiled kapicorp-demo-march (0.03s)\nCompiled kapicorp-terraform-admin (0.03s)\nCompiled sock-shop (0.32s)\nCompiled tesoro (0.09s)\nCompiled dev-sockshop (0.32s)\nCompiled prod-sockshop (0.38s)\nCompiled argocd (2.29s)\n</code></pre>"},{"location":"pages/commands/kapitan_compile/#selective-compilation","title":"Selective compilation","text":""},{"location":"pages/commands/kapitan_compile/#using-target-names","title":"Using target names","text":"<p>Compiles one or more targets selected by name using <code>--targets</code> or <code>-t</code></p> <pre><code>kapitan compile -t mysql tesoro\n</code></pre> click to expand output <pre><code>Compiled mysql (0.06s)\nCompiled tesoro (0.09s)\n</code></pre>"},{"location":"pages/commands/kapitan_compile/#using-labels","title":"Using labels","text":"<p>Compiles one or more targets selected matching labels with  <code>--labels</code> or <code>-l</code></p> <p>Info</p> <p>This works if you have labelled your targets using the following syntax:</p> <pre><code>parameters:\n  ...\n  kapitan:\n    ...\n    labels:\n      customer: acme\n</code></pre> <p>see Labels for more details</p> <pre><code>$ kapitan compile -l customer=acme\nCompiled acme-project (0.14s)\nCompiled acme-pipelines (0.10s)\n</code></pre>"},{"location":"pages/commands/kapitan_compile/#fetch-on-compile","title":"Fetch on compile","text":"<p>Use the <code>--fetch</code> flag to fetch Remote Inventories and the External Dependencies.</p> <pre><code>kapitan compile --fetch\n</code></pre> <p>This will download the dependencies according to their configurations By default, kapitan does not overwrite an existing item with the same name as that of the fetched inventory items.</p> <p>Use the <code>--force-fetch</code> flag to force fetch (update cache with freshly fetched items) and overwrite inventory items of the same name in the <code>output_path</code>.</p> <pre><code>kapitan compile --force-fetch\n</code></pre> <p>Use the <code>--cache</code> flag to cache the fetched items in the <code>.dependency_cache</code> directory in the root project directory.</p> <pre><code>kapitan compile --cache --fetch\n</code></pre>"},{"location":"pages/commands/kapitan_compile/#embed-references","title":"Embed references","text":"<p>By default, Kapitan references are stored encrypted (for backends that support encription) in the configuration repository under the <code>/refs</code> directory.</p> <p>For instance, a reference tag <code>?{gpg:targets/minikube-mysql/mysql/password:ec3d54de}</code> would point to a phisical file on disk under <code>/refs</code> like:</p> <p><code>refs/targets/minikube-mysql/mysql/password</code></p> <pre><code>data: hQEMA8uOJKdm07XTAQgAp5i [[ CUT ]] BwqYc3g7PI09HCJZdU=\nencoding: base64\nrecipients:\n- fingerprint: D9234C61F58BEB3ED8552A57E28DC07A3CBFAE7C\ntype: gpg\n</code></pre> <p>The <code>--embed-refs</code> flags tells Kapitan to embed these references on compile, alongside the generated output. By doing so, compiled output is self-contained and can be revealed by Tesoro or other tools.</p> <pre><code>kapitan compile --embed-refs\n</code></pre> <p>See how the compiled output for this specific target changes to embed the actul encrypted content, (marked by <code>?{gpg: :embedded}</code> to indicate it is a gpg reference) rather than just holding a reference to it (like in this case <code>?{gpg:targets/minikube-mysql/mysql/password:ec3d54de}</code> which points to ).</p> click to expand output <pre><code>diff --git a/examples/kubernetes/compiled/minikube-mysql/manifests/mysql_app.yml b/examples/kubernetes/compiled/minikube-mysql/manifests/mysql_app.yml\n[[ CUT ]]\napiVersion: v1\ndata:\n-  MYSQL_ROOT_PASSWORD: ?{gpg:targets/minikube-mysql/mysql/password:ec3d54de}\n-  MYSQL_ROOT_PASSWORD_SHA256: ?{gpg:targets/minikube-mysql/mysql/password_sha256:122d2732}\n+  MYSQL_ROOT_PASSWORD: ?{gpg:eyJkYXRhIjogImhR [[ CUT ]] gInR5cGUiOiAiZ3BnIn0=:embedded}\n+  MYSQL_ROOT_PASSWORD_SHA256: ?{gpg:eyJkYXRhI [[ CUT ]] eXBlIjogImdwZyJ9:embedded}\n</code></pre>"},{"location":"pages/commands/kapitan_compile/#help","title":"help","text":"<pre><code>kapitan compile --help\n</code></pre> click to expand output <pre><code>usage: kapitan compile [-h] [--inventory-backend {reclass}]\n               [--search-paths JPATH [JPATH ...]]\n               [--jinja2-filters FPATH] [--verbose] [--prune]\n               [--quiet] [--output-path PATH] [--fetch]\n               [--force-fetch] [--force] [--validate]\n               [--parallelism INT] [--indent INT]\n               [--refs-path REFS_PATH] [--reveal] [--embed-refs]\n               [--inventory-path INVENTORY_PATH] [--cache]\n               [--cache-paths PATH [PATH ...]]\n               [--ignore-version-check] [--use-go-jsonnet]\n               [--compose-target-name] [--schemas-path SCHEMAS_PATH]\n               [--yaml-multiline-string-style STYLE]\n               [--yaml-dump-null-as-empty]\n               [--targets TARGET [TARGET ...] | --labels\n               [key=value ...]]\n\noptions:\n  -h, --help            show this help message and exit\n  --inventory-backend {reclass,reclass-rs}\n                        Select the inventory backend to use (default=reclass)\n  --search-paths JPATH [JPATH ...], -J JPATH [JPATH ...]\n                        set search paths, default is [\".\"]\n  --jinja2-filters FPATH, -J2F FPATH\n                        load custom jinja2 filters from any file, default is\n                        to put them inside lib/jinja2_filters.py\n  --verbose, -v         set verbose mode\n  --prune               prune jsonnet output\n  --quiet               set quiet mode, only critical output\n  --output-path PATH    set output path, default is \".\"\n  --fetch               fetch remote inventories and/or external dependencies\n  --force-fetch         overwrite existing inventory and/or dependency item\n  --force               overwrite existing inventory and/or dependency item\n  --validate            validate compile output against schemas as specified\n                        in inventory\n  --parallelism INT, -p INT\n                        Number of concurrent compile processes, default is 4\n  --indent INT, -i INT  Indentation spaces for YAML/JSON, default is 2\n  --refs-path REFS_PATH\n                        set refs path, default is \"./refs\"\n  --reveal              reveal refs (warning: this will potentially write\n                        sensitive data)\n  --embed-refs          embed ref contents\n  --inventory-path INVENTORY_PATH\n                        set inventory path, default is \"./inventory\"\n  --cache, -c           enable compilation caching to .kapitan_cache and\n                        dependency caching to .dependency_cache, default is\n                        False\n  --cache-paths PATH [PATH ...]\n                        cache additional paths to .kapitan_cache, default is\n                        []\n  --ignore-version-check\n                        ignore the version from .kapitan\n  --use-go-jsonnet      use go-jsonnet\n  --compose-target-name   Create same subfolder structure from inventory/targets\n                        inside compiled folder\n  --schemas-path SCHEMAS_PATH\n                        set schema cache path, default is \"./schemas\"\n  --yaml-multiline-string-style STYLE, -L STYLE\n                        set multiline string style to STYLE, default is\n                        'double-quotes'\n  --yaml-dump-null-as-empty\n                        dumps all none-type entries as empty, default is\n                        dumping as 'null'\n  --targets TARGET [TARGET ...], -t TARGET [TARGET ...]\n                        targets to compile, default is all\n  --labels [key=value ...], -l [key=value ...]\n                        compile targets matching the labels, default is all\n</code></pre>"},{"location":"pages/commands/kapitan_dotfile/","title":"CLI Reference | <code>.kapitan</code> config file","text":""},{"location":"pages/commands/kapitan_dotfile/#kapitan","title":"<code>.kapitan</code>","text":"<p>Kapitan allows you to coveniently override defaults by specifying a local <code>.kapitan</code> file in the root of your repository (relative to the kapitan configuration):</p> <p>This comes handy to make sure Kapitan runs consistently for your specific setup.</p> <p>Info</p> <p>Any Kapitan command can be overridden in the <code>.kapitan</code> dotfile, but here are some of the most common examples.</p>"},{"location":"pages/commands/kapitan_dotfile/#version","title":"<code>version</code>","text":"<p>To enforce the Kapitan version used for compilation (for consistency and safety), you can add <code>version</code> to <code>.kapitan</code>:</p> <pre><code>version: 0.30.0\n\n...\n</code></pre> <p>This constrain can be relaxed to allow minor versions to be also accepted:</p> <pre><code>version: 0.30 # Allows any 0.30.x release to run\n\n...\n</code></pre>"},{"location":"pages/commands/kapitan_dotfile/#command-line-flags","title":"Command line flags","text":"<p>You can also permanently define all command line flags in the <code>.kapitan</code> config file. For example:</p> <pre><code>...\n\ncompile:\n  indent: 4\n  parallelism: 8\n</code></pre> <p>would be equivalent to running:</p> <pre><code>kapitan compile --indent 4 --parallelism 8\n</code></pre> <p>For flags which are shared by multiple commands, you can either selectively define them for single commmands in a section with the same name as the command, or you can set any flags in section <code>global</code>, in which case they're applied for all commands. If you set a flag in both the <code>global</code> section and a command's section, the value from the command's section takes precedence over the value from the global section.</p> <p>As an example, you can configure the <code>inventory-path</code> in the <code>global</code> section of the Kapitan dotfile to make sure it's persisted across all Kapitan runs.</p> <pre><code>...\n\nglobal:\n  inventory-path: ./some_path\n</code></pre> <p>which would be equivalent to running any command with <code>--inventory-path=./some_path</code>.</p> <p>Another flag that you may want to set in the <code>global</code> section is <code>inventory-backend</code> to select a non-default inventory backend implementation.</p> <pre><code>global:\n  inventory-backend: reclass\n</code></pre> <p>which would be equivalent to always running Kapitan with <code>--inventory-backend=reclass</code>.</p> <p>Please note that the <code>inventory-backend</code> flag currently can't be set through the command-specific sections of the Kapitan config file.</p>"},{"location":"pages/commands/kapitan_inventory/","title":"CLI Reference | <code>kapitan inventory</code>","text":""},{"location":"pages/commands/kapitan_inventory/#kapitan-inventory","title":"<code>kapitan inventory</code>","text":"<p>Renders the resulting inventory values for a specific target.</p> <p>For example, rendering the inventory for the <code>mysql</code> target:</p> <pre><code>kapitan inventory -t mysql\n</code></pre> click to expand output <pre><code>__reclass__:\n  environment: base\n  name: mysql\n  node: mysql\n  timestamp: Wed Nov 23 23:19:28 2022\n  uri: yaml_fs:///src/inventory/targets/examples/mysql.yml\napplications: []\nclasses:\n  - kapitan.kube\n  - kapitan.generators.kubernetes\n  - kapitan.generators.argocd\n  - kapitan.generators.terraform\n  - kapitan.generators.rabbitmq\n  - kapitan.common\n  - common\n  - components.mysql\nenvironment: base\nexports: {}\nparameters:\n  _reclass_:\n    environment: base\n    name:\n      full: mysql\n      short: mysql\n  components:\n    mysql:\n      config_maps:\n        config:\n          data:\n            mysql.cnf:\n              value: ignore-db-dir=lost+found\n            mytemplate.cnf:\n              template: components/mysql/mytemplate.cnf.j2\n              values:\n                mysql:\n                  client:\n                    port: 3306\n                    socket: /var/run/mysqld/mysqld.sock\n                  mysqld:\n                    bind-address: 127.0.0.1\n                    max_allowed_packet: 64M\n                    thread_concurrency: 8\n          mount: /etc/mysql/conf.d/\n      env:\n        MYSQL_DATABASE: ''\n        MYSQL_PASSWORD:\n          secretKeyRef:\n            key: mysql-password\n        MYSQL_ROOT_PASSWORD:\n          secretKeyRef:\n            key: mysql-root-password\n        MYSQL_USER: ''\n      image: mysql:5.7.28\n      ports:\n        mysql:\n          service_port: 3306\n      secrets:\n        secrets:\n          data:\n            mysql-password:\n              value: ?{plain:targets/mysql/mysql-password||randomstr|base64}\n            mysql-root-password:\n              value: ?{plain:targets/mysql/mysql-root-password||randomstr:32|base64}\n          versioned: true\n      type: statefulset\n      volume_claims:\n        datadir:\n          spec:\n            accessModes:\n              - ReadWriteOnce\n            resources:\n              requests:\n                storage: 10Gi\n            storageClassName: standard\n      volume_mounts:\n        datadir:\n          mountPath: /var/lib/mysql\n  docs:\n    - templates/docs/README.md\n  generators:\n    manifest:\n      default_config:\n        annotations:\n          manifests.kapicorp.com/generated: 'true'\n        service_account:\n          create: false\n        type: deployment\n  kapitan:\n    compile:\n      - input_paths:\n          - components/generators/kubernetes\n        input_type: kadet\n        output_path: manifests\n        output_type: yml\n      - input_params:\n          function: generate_docs\n          template_path: templates/docs/service_component.md.j2\n        input_paths:\n          - components/generators/kubernetes\n        input_type: kadet\n        output_path: docs\n        output_type: plain\n      - input_params:\n          function: generate_pre_deploy\n        input_paths:\n          - components/generators/kubernetes\n        input_type: kadet\n        output_path: pre-deploy\n        output_type: yml\n      - input_paths:\n          - components/generators/argocd\n        input_type: kadet\n        output_path: argocd\n        output_type: yml\n      - input_params:\n          generator_root: resources.tf\n        input_paths:\n          - components/generators/terraform\n        input_type: kadet\n        output_path: terraform\n        output_type: json\n      - ignore_missing: true\n        input_paths:\n          - resources/state/mysql/.terraform.lock.hcl\n        input_type: copy\n        output_path: terraform/\n      - input_paths:\n          - components/generators/rabbitmq\n        input_type: kadet\n        output_path: rabbitmq\n        output_type: yml\n      - input_paths:\n          - templates/docs/README.md\n        input_type: jinja2\n        output_path: docs\n      - input_paths: []\n        input_type: jinja2\n        output_path: scripts\n      - input_paths: []\n        input_type: jsonnet\n        output_path: manifests\n        output_type: yml\n    dependencies:\n      - output_path: lib/kube.libsonnet\n        source: https://raw.githubusercontent.com/bitnami-labs/kube-libsonnet/master/kube.libsonnet\n        type: https\n      - output_path: lib/kube-platforms.libsonnet\n        source: https://raw.githubusercontent.com/bitnami-labs/kube-libsonnet/master/kube-platforms.libsonnet\n        type: https\n      - output_path: components/generators/kubernetes\n        ref: master\n        source: https://github.com/kapicorp/kapitan-reference.git\n        subdir: components/generators/kubernetes\n        type: git\n      - output_path: components/generators/terraform\n        ref: master\n        source: https://github.com/kapicorp/kapitan-reference.git\n        subdir: components/generators/terraform\n        type: git\n    vars:\n      target: mysql\n  manifests: []\n  mysql:\n    settings:\n      client:\n        port: 3306\n        socket: /var/run/mysqld/mysqld.sock\n      mysqld:\n        bind-address: 127.0.0.1\n        max_allowed_packet: 64M\n        thread_concurrency: 8\n  namespace: mysql\n  scripts: []\n  target_name: mysql\n</code></pre>"},{"location":"pages/commands/kapitan_lint/","title":"CLI Reference | <code>kapitan lint</code>","text":""},{"location":"pages/commands/kapitan_lint/#kapitan-lint","title":"<code>kapitan lint</code>","text":"<p>Perform a checkup on your inventory or refs.</p> <pre><code>./kapitan lint\n</code></pre> click to expand output <pre><code>Running yamllint on all inventory files...\n\n.yamllint not found. Using default values\nFile ./inventory/classes/components/echo-server.yml has the following issues:\n        95:29: forbidden implicit octal value \"0550\" (octal-values)\nFile ./inventory/classes/terraform/gcp/services.yml has the following issues:\n        15:11: duplication of key \"enable_compute_service\" in mapping (key-duplicates)\n\nTotal yamllint issues found: 2\n\nChecking for orphan classes in inventory...\n\nNo usage found for the following 6 classes:\n{'components.argoproj.cd.argocd-server-oidc',\n'components.helm.cert-manager-helm',\n'components.rabbitmq-operator.rabbitmq-configuration',\n'components.rabbitmq-operator.rabbitmq-operator',\n'features.gkms-demo',\n'projects.localhost.kubernetes.katacoda'}\n</code></pre>"},{"location":"pages/commands/kapitan_searchvar/","title":"CLI Reference | <code>kapitan searchvar</code>","text":""},{"location":"pages/commands/kapitan_searchvar/#kapitan-searchvar","title":"<code>kapitan searchvar</code>","text":"<p>Shows all inventory files where a variable is declared:</p> <pre><code>./kapitan searchvar parameters.components.*.image\n</code></pre> click to expand output <pre><code>./inventory/classes/components/vault.yml                     ${vault:image}\n./inventory/classes/components/logstash.yml                  eu.gcr.io/antha-images/logstash:7.5.1\n./inventory/classes/components/gke-pvm-killer.yml            estafette/estafette-gke-preemptible-killer:1.2.5\n./inventory/classes/components/mysql.yml                     mysql:5.7.28\n./inventory/classes/components/postgres-proxy.yml            gcr.io/cloudsql-docker/gce-proxy:1.16\n./inventory/classes/components/echo-server.yml               jmalloc/echo-server\n./inventory/classes/components/trivy.yml                     ${trivy:image}\n./inventory/classes/components/filebeat.yml                  ${filebeat:image}:${filebeat:version}\n./inventory/classes/components/pritunl/pritunl-mongo.yml     docker.io/bitnami/mongodb:4.2.6-debian-10-r23\n./inventory/classes/components/pritunl/pritunl.yml           alledm/pritunl\n./inventory/classes/components/weaveworks/user-db.yml        weaveworksdemos/user-db:0.3.0\n./inventory/classes/components/weaveworks/catalogue.yml      weaveworksdemos/catalogue:0.3.5\n./inventory/classes/components/weaveworks/user.yml           weaveworksdemos/user:0.4.7\n./inventory/classes/components/weaveworks/session-db.yml     redis:alpine\n./inventory/classes/components/weaveworks/catalogue-db.yml   weaveworksdemos/catalogue-db:0.3.0\n./inventory/classes/components/weaveworks/carts-db.yml       mongo\n./inventory/classes/components/weaveworks/orders-db.yml      mongo\n./inventory/classes/components/weaveworks/orders.yml         weaveworksdemos/orders:0.4.7\n./inventory/classes/components/weaveworks/shipping.yml       weaveworksdemos/shipping:0.4.8\n./inventory/classes/components/weaveworks/queue-master.yml   weaveworksdemos/queue-master:0.3.1\n./inventory/classes/components/weaveworks/rabbitmq.yml       rabbitmq:3.6.8-management\n./inventory/classes/components/weaveworks/payment.yml        weaveworksdemos/payment:0.4.3\n./inventory/classes/components/weaveworks/front-end.yml      weaveworksdemos/front-end:0.3.12\n./inventory/classes/components/weaveworks/carts.yml          weaveworksdemos/carts:0.4.8\n./inventory/classes/components/kapicorp/tesoro.yml           kapicorp/tesoro\n</code></pre>"},{"location":"pages/commands/kapitan_validate/","title":"CLI Reference | <code>kapitan validate</code>","text":""},{"location":"pages/commands/kapitan_validate/#kapitan-validate","title":"<code>kapitan validate</code>","text":"<p>Validates the schema of compiled output. Validate options are specified in the inventory under <code>parameters.kapitan.validate</code>. Supported types are:</p>"},{"location":"pages/commands/kapitan_validate/#usage","title":"Usage","text":"standalonemanual with <code>kapitan compile</code>automatic with <code>.kapitan</code> dotfile <pre><code>kapitan validate\n</code></pre> click to expand output <pre><code>created schema-cache-path at ./schemas\nValidation: manifest validation successful for ./compiled/minikube-mysql/manifests/mysql_secret.yml\nValidation: manifest validation successful for ./compiled/minikube-mysql/manifests/mysql_service_jsonnet.yml\nValidation: manifest validation successful for ./compiled/minikube-mysql/manifests/mysql_service_simple.yml\n</code></pre> <pre><code>kapitan compile --validate\n</code></pre> click to expand output <pre><code>Rendered inventory (0.27s)\nCompiled labels (0.23s)\nCompiled removal (0.00s)\nCompiled busybox (0.24s)\nCompiled minikube-nginx-jsonnet (0.49s)\nCompiled minikube-nginx-kadet (0.25s)\nCompiled minikube-mysql (0.59s)\nCompiled minikube-es (1.17s)\nCompiled all-glob (1.55s)\nValidation: manifest validation successful for ./compiled/minikube-mysql/manifests/mysql_secret.yml\nValidation: manifest validation successful for ./compiled/minikube-mysql/manifests/mysql_service_jsonnet.yml\nValidation: manifest validation successful for ./compiled/minikube-mysql/manifests/mysql_service_simple.yml\n</code></pre> <p>You can leverage the <code>.kapitan</code> dotfile to make sure validate runs every time you run compile.</p> <p>example <code>.kapitan</code></p> <pre><code>...\n\ncompile:\n  validate: true\n</code></pre> <p>The <code>validate</code> command will now be implied for every compile run <pre><code>kapitan compile\n</code></pre></p> click to expand output <pre><code>Rendered inventory (0.27s)\nCompiled labels (0.23s)\nCompiled removal (0.00s)\nCompiled busybox (0.24s)\nCompiled minikube-nginx-jsonnet (0.49s)\nCompiled minikube-nginx-kadet (0.25s)\nCompiled minikube-mysql (0.59s)\nCompiled minikube-es (1.17s)\nCompiled all-glob (1.55s)\nValidation: manifest validation successful for ./compiled/minikube-mysql/manifests/mysql_secret.yml\nValidation: manifest validation successful for ./compiled/minikube-mysql/manifests/mysql_service_jsonnet.yml\nValidation: manifest validation successful for ./compiled/minikube-mysql/manifests/mysql_service_simple.yml\n</code></pre>"},{"location":"pages/commands/kapitan_validate/#kubernetes-setup","title":"Kubernetes Setup","text":"<p>Kubernetes has different resource kinds, for instance:</p> <ul> <li><code>service</code></li> <li><code>deployment</code></li> <li><code>statefulset</code></li> </ul> <p>Kapitan has built in support for validation of Kubernetes kinds, and automatically integrates with https://kubernetesjsonschema.dev. See github.com/instrumenta/kubernetes-json-schema for more informations.</p> <p>Info</p> <p>Kapitan will automatically download the schemas for Kubernetes Manifests directly from https://kubernetesjsonschema.dev </p> <p>By default, the schemas are cached into <code>./schemas/</code>, which can be modified with the <code>--schemas-path</code> option.</p> <p>override permanently <code>schema-path</code></p> <p>Remember to use the <code>.kapitan</code> dotfile configuration to override permanently the <code>schema-path</code> location.</p> <pre><code>$ cat .kapitan\n# other options abbreviated for clarity\nvalidate:\n  schemas-path: custom/schemas/cache/path\n</code></pre>"},{"location":"pages/commands/kapitan_validate/#example","title":"Example","text":"<p>Refer to the <code>mysql</code> example.</p> kubernetes/inventory/classes/component/mysql.yml<pre><code>    validate: \n    - type: kubernetes # mkdocs (1)! \n      output_paths: # mkdocs (2)! \n        - manifests/mysql_secret.yml\n      kind: secret # temporarily replaced with 'deployment' during test # mkdocs (3)! \n      version: 1.14.0 # optional, defaults to 1.14.0 # mkdocs (4)! \n    - type: kubernetes\n      output_paths:\n        - manifests/mysql_service_jsonnet.yml\n        - manifests/mysql_service_simple.yml\n      kind: service\n      version: 1.14.0\n</code></pre> <ol> <li><code>type</code> | currently only Kubernetes is supported</li> <li><code>output_paths</code> | list of files to validate</li> <li><code>kind</code> | a Kubernetes resource kind</li> <li><code>version</code> | a Kubernetes API version, defaults to <code>1.14.0</code></li> </ol>"},{"location":"pages/contribute/code/","title":"Kapitan code","text":"<p>Many of our features come from contributions from external collaborators. Please help us improve Kapitan by extending it with your ideas, or help us squash bugs you discover.</p> <p>It's simple, just send us a PR with your improvements!</p>","tags":["community"]},{"location":"pages/contribute/code/#submitting-code","title":"Submitting code","text":"<p>We would like ask you to fork Kapitan project and create a Pull Request targeting master branch. All submissions, including submissions by project members, require review.</p>","tags":["community"]},{"location":"pages/contribute/code/#setup","title":"Setup","text":"<p>We build kapitan using <code>poetry</code>.</p> <ol> <li> <p>Install poetry</p> <pre><code>pip install poetry\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>poetry install --with test\n</code></pre> <p>Poetry creates a virtual environment with the required dependencies installed.</p> </li> <li> <p>Run kapitan with the own compiled code</p> <pre><code>poetry run kapitan &lt;your command&gt;\n</code></pre> </li> </ol> <p>Because we are using a pinned version of reclass which is added as a submodule into Kapitan's repository, you need to pull it separately by executing the command below:</p> <pre><code>git submodule update --init\n</code></pre>","tags":["community"]},{"location":"pages/contribute/code/#troubleshoot","title":"Troubleshoot","text":"<p>Check if gcc is installed:</p> <pre><code>brew install gcc@5\n</code></pre>","tags":["community"]},{"location":"pages/contribute/code/#testing","title":"Testing","text":"<p>Run <code>make test</code> to run all tests. If you modify anything in the <code>examples/</code> folder make sure you replicate the compiled result of that in <code>tests/test_kubernetes_compiled</code>. If you add new features, run <code>make test_coverage &amp;&amp; make test_formatting</code> to make sure the test coverage remains at current or better levels and that code formatting is applied.</p> <p>If you would like to evaluate your changes by running your version of Kapitan, you can do that by running <code>bin/kapitan</code> from this repository or even setting an alias to it.</p> <pre><code>python3 -m unittest tests/test_vault_transit.py\n</code></pre>","tags":["community"]},{"location":"pages/contribute/code/#code-style","title":"Code Style","text":"<p>To make sure you adhere to the Style Guide for Python (PEP8) Python Black is used to apply the formatting so make sure you have it installed with <code>pip3 install black</code>.</p>","tags":["community"]},{"location":"pages/contribute/code/#apply-via-git-hook","title":"Apply via Git hook","text":"<ul> <li>Run <code>pip3 install pre-commit</code> to install precommit framework.</li> <li>In the Kapitan root directory, run <code>pre-commit install</code></li> <li>Git add/commit any changed files you want.</li> </ul>","tags":["community"]},{"location":"pages/contribute/code/#apply-manually","title":"Apply manually","text":"<p>Run <code>make format_codestyle</code> before submitting.</p>","tags":["community"]},{"location":"pages/contribute/code/#release-process","title":"Release process","text":"<ul> <li>Create a branch named <code>release-v&lt;NUMBER&gt;</code>. Use <code>v0.*.*-rc.*</code> if you want pre-release versions to be uploaded.</li> <li>Update CHANGELOG.md with the release changes.</li> <li>Once reviewed and merged, Github Actions will auto-release.</li> <li>The merge has to happen with a merge commit not with squash/rebase so that the commit message still mentions <code>kapicorp/release-v*</code> inside.</li> </ul>","tags":["community"]},{"location":"pages/contribute/code/#packaging-extra-resources-in-python-package","title":"Packaging extra resources in python package","text":"<p>To package any extra resources/files in the pip package, make sure you modify both <code>MANIFEST.in</code>.</p>","tags":["community"]},{"location":"pages/contribute/code/#leave-a-comment","title":"Leave a comment","text":"","tags":["community"]},{"location":"pages/contribute/documentation/","title":"Documentation","text":"<p>Our documentation usully prevents new users from adopting Kapitan. Help us improve by contributing with fixes and keeping it up-to-date.</p>","tags":["community"]},{"location":"pages/contribute/documentation/#articles","title":"Articles","text":"<p>Write articles on Kapitan and share your way of working. Inspire others, and reach out to have your article published / endorsed by us.</p>","tags":["community"]},{"location":"pages/contribute/documentation/#this-website","title":"This Website","text":"<p>Find something odd? Let us know or change it yourself: you can edit pages of this website on Github by clicking the pencil icon at the top right of this page!</p>","tags":["community"]},{"location":"pages/contribute/documentation/#update-documentation","title":"Update documentation","text":"<p>We use mkdocs to generate our gh-pages from <code>.md</code> files under docs/ folder.</p> <p>Updating our gh-pages is therefore a two-step process.</p>","tags":["community"]},{"location":"pages/contribute/documentation/#update-the-markdown","title":"Update the markdown","text":"<p>Submit a PR for our master branch that updates the <code>.md</code> file(s). Test how the changes would look like when deployed to gh-pages by serving it on localhost:</p> <ol> <li>Edit the <code>strict</code> property in <code>mkdocs.yml</code> and set it to <code>false</code>.</li> <li><code>make local_serve_documentation</code></li> <li>Now the documentation site should be available at <code>localhost:8000</code>.</li> </ol>","tags":["community"]},{"location":"pages/contribute/documentation/#submit-a-pr","title":"Submit a PR","text":"<p>Once the above PR has been merged, use <code>mkdocs gh-deploy</code> command to push the commit that updates the site content to your own gh-pages branch. Make sure that you already have this gh-pages branch in your fork that is up-to-date with our gh-pages branch such that the two branches share the commit history (otherwise Github would not allow PRs to be created).</p> <pre><code># locally, on master branch (which has your updated docs)\nCOMMIT_MSG=\"your commit message to replace\" make mkdocs_gh_deploy\n</code></pre> <p>After it's pushed, create a PR that targets our gh-pages branch from your gh-pages branch.</p>","tags":["community"]},{"location":"pages/contribute/sponsor/","title":"Sponsor Kapitan","text":"<p>Do you want to help the project? Great! There are many ways to do it</p> <p> </p> <p>We accept donations throught GitHubs Sponsors. Alternatively reach out for other ways to support us.</p> <p>Companies and individuals sponsoring us on a regular base will be recognised and called out on our website</p>","tags":["community"]},{"location":"pages/contribute/talk/","title":"Talk about Kapitan","text":"<p>Our project needs your support to get noticed! Please let everyone know that you are using Kapitan</p> <ul> <li> Help us grow: give us a star</li> <li>Join us on kubernetes.slack.com <code>#kapitan</code>(Get invited)</li> <li>Tweet about us on Twitter . Remember to add @kapitandev to your tweets</li> <li>Share our website <code>https://kapitan.dev</code></li> <li>Write tutorials and blog posts and join the many who have done it already! Get published on the Kapitan Blog</li> <li>Share what Kapitan does for you and for your company</li> <li>Inspire your colleagues and network on LinkedIn</li> </ul>"},{"location":"pages/input_types/copy/","title":"Copy","text":"<p>This input type simply copies the input templates to the output directory without any rendering/processing. For Copy, <code>input_paths</code> can be either a file or a directory: in case of a directory, all the templates in the directory will be copied and outputted to <code>output_path</code>.</p> <p>Supported output types: N/A (no need to specify <code>output_type</code>)</p> <p>Example</p> <pre><code> kapitan:\n    compile:\n      - input_type: copy\n        ignore_missing: true  # Do not error if path is missing. Defaults to False\n        input_paths:\n          - resources/state/${target_name}/.terraform.lock.hcl\n        output_path: terraform/\n</code></pre>"},{"location":"pages/input_types/external/","title":"External","text":"<p>This input type executes an external script or binary. This can be used to manipulate already compiled files or execute binaries outside of kapitan that generate or manipulate files.</p> <p>For example, ytt is a useful yaml templating tool. It is not built into the kapitan binary, however, with the <code>external</code> input type, we could specify the <code>ytt</code> binary to be executed with specific arguments and environment variables.</p> <p>In this example, we're removing a label from a k8s manifests in a directory <code>ingresses</code> and placing it into the compiled target directory.</p> <pre><code>parameters:\n  target_name: k8s-manifests\n  kapitan:\n    vars:\n      target: ${target_name}\n    compile:\n      - input_type: external\n        input_paths:\n          - /usr/local/bin/ytt # path to ytt on system\n        output_path: .\n        args:\n          - -f\n          - ingresses/ # directory with ingresses\n          - -f\n          - ytt/remove.yaml # custom ytt script\n          - \"&gt;\"\n          - \\${compiled_target_dir}/ingresses/ingresses.yaml # final merged result\n</code></pre> <p>Supported output types: N/A (no need to specify <code>output_type</code>)</p> <p>Additionally, the input type supports field <code>env_vars</code>, which can be used to set environment variables for the external command. By default, the external command doesn't inherit any environment variables from Kapitan's environment. However, if environment variables <code>$PATH</code> or <code>$HOME</code> aren't set in <code>env_vars</code>, they will be propagated from Kapitan's environment to the external command's environment.</p> <p>Finally, Kapitan will substitute <code>${compiled_target_dir}</code> in both the command's arguments and the environment variables. This variable needs to be escaped in the configuration to ensure that reclass won't interpret it as a reclass reference.</p>"},{"location":"pages/input_types/helm/","title":"Input Type | Helm","text":"<p>This is a Python binding to <code>helm template</code> command for users with helm charts. This does not require the helm executable, and the templates are rendered without the Tiller server.</p> <p>Unlike other input types, Helm input types support the following additional parameters under <code>kapitan.compile</code>:</p> <pre><code>parameters:\n  kapitan:\n    compile:\n    - output_path: &lt;output_path&gt;\n      input_type: helm\n      input_paths:\n        - &lt;chart_path&gt;\n      helm_values:\n        &lt;object_with_values_to_override&gt;\n      helm_values_files:\n        - &lt;values_file_path&gt;\n      helm_path: &lt;helm binary&gt;\n      helm_params:\n        name: &lt;chart_release_name&gt;\n        namespace: &lt;substitutes_.Release.Namespace&gt;\n        output_file: &lt;string&gt;\n        validate: true\n        \u2026\n</code></pre> <p><code>helm_values</code> is an object containing values specified that will override the default values in the input chart. This has exactly the same effect as specifying <code>--values custom_values.yml</code> for <code>helm template</code> command where <code>custom_values.yml</code> structure mirrors that of <code>helm_values</code>.</p> <p><code>helm_values_files</code> is an array containing the paths to helm values files used as input for the chart. This has exactly the same effect as specifying <code>--file my_custom_values.yml</code> for the <code>helm template</code> command where <code>my_custom_values.yml</code> is a helm values file. If the same keys exist in <code>helm_values</code> and in multiple specified <code>helm_values_files</code>, the last indexed file in the <code>helm_values_files</code> will take precedence followed by the preceding <code>helm_values_files</code> and at the bottom the <code>helm_values</code> defined in teh compile block. There is an example in the tests. The <code>monitoring-dev</code>(kapitan/tests/test_resources/inventory/targets/monitoring-dev.yml) and <code>monitoring-prd</code>(kapitan/tests/test_resources/inventory/targets/monitoring-prd.yml) targets  both use the <code>monitoring</code>(tests/test_resources/inventory/classes/component/monitoring.yml) component. This component has helm chart input and takes a <code>common.yml</code> helm_values file which is \"shared\" by any target that uses the component and it also takes a dynamically defined file based on a kapitan variable defined in the target.</p> <p><code>helm_path</code> can be use to provide the helm binary name or path. <code>helm_path</code> defaults to the value of <code>KAPITAN_HELM_PATH</code> env var if it is set, else it defaults to <code>helm</code></p> <p><code>helm_params</code> correspond to the flags for <code>helm template</code>. Most flags that helm supports can be used here by replacing '-' by '_' in the flag name.</p> <p>Flags without argument must have a boolean value, all other flags require a string value.</p> <p>Special flags:</p> <ul> <li><code>name</code>: equivalent of helm template <code>[NAME]</code> parameter. Ignored if <code>name_template</code> is also specified. If neither <code>name_template</code> nor <code>name</code> are specified, the <code>--generate-name</code> flag is used to generate a name.</li> <li> <p><code>output_file</code>: name of the single file used to output all the generated resources. This is equivalent to call <code>helm template</code> without specifing output dir. If not specified, each resource is generated into a distinct file.</p> </li> <li> <p><code>include_crds</code> and <code>skip_tests</code>: These flags are enabled by default and should be set to <code>false</code> to be removed.</p> </li> <li><code>debug</code>: prints the helm debug output in kapitan debug log.</li> <li> <p><code>namespace</code>: note that due to the restriction on <code>helm template</code> command, specifying the namespace does not automatically add <code>metadata.namespace</code> property to the resources. Therefore, users are encouraged to explicitly specify it in all resources:</p> <pre><code>metadata:\n  namespace: {{ .Release.Namespace }} # or any other custom values\n</code></pre> </li> </ul> <p>See the helm doc for further detail.</p>"},{"location":"pages/input_types/helm/#example","title":"Example","text":"<p>Let's use nginx-ingress helm chart as the input. Using kapitan dependency manager, this chart can be fetched via a URL as listed in https://helm.nginx.com/stable/index.yaml.</p> <p>On a side note, <code>https://helm.nginx.com/stable/</code> is the chart repository URL which you would <code>helm repo add</code>, and this repository should contain <code>index.yaml</code> that lists out all the available charts and their URLs. By locating this <code>index.yaml</code> file, you can locate all the charts available in the repository.</p> <p>We can use version 0.3.3 found at https://helm.nginx.com/stable/nginx-ingress-0.3.3.tgz. We can create a simple target file as <code>inventory/targets/nginx-from-chart.yml</code> whose content is as follows:</p> <pre><code>parameters:\n  kapitan:\n    vars:\n      target: nginx-from-chart\n    dependencies:\n    - type: https\n      source: https://helm.nginx.com/stable/nginx-ingress-0.3.3.tgz\n      unpack: True\n      output_path: components/charts\n    compile:\n      - output_path: .\n        input_type: helm\n        input_paths:\n          - components/charts/nginx-ingress\n        helm_values:\n          controller:\n            name: my-controller\n            image:\n              repository: custom_repo\n        helm_params:\n          name: my-first-release-name\n          namespace: my-first-namespace\n</code></pre> <p>To compile this target, run:</p> <pre><code>$ kapitan compile --fetch\nDependency https://helm.nginx.com/stable/nginx-ingress-0.3.3.tgz : fetching now\nDependency https://helm.nginx.com/stable/nginx-ingress-0.3.3.tgz : successfully fetched\nDependency https://helm.nginx.com/stable/nginx-ingress-0.3.3.tgz : extracted to components/charts\nCompiled nginx-from-chart (0.07s)\n</code></pre> <p>The chart is fetched before compile, which creates <code>components/charts/nginx-ingress</code> folder that is used as the <code>input_paths</code>  for the helm input type. To confirm if the <code>helm_values</code> actually has overridden the default values, we can try:</p> <pre><code>$ grep \"my-controller\" compiled/nginx-from-chart/nginx-ingress/templates/controller-deployment.yaml\n  name: my-controller\n      app: my-controller\n        app: my-controller\n</code></pre>"},{"location":"pages/input_types/helm/#building-the-binding-from-source","title":"Building the binding from source","text":"<p>Run</p> <pre><code>cd kapitan/inputs/helm\n./build.sh\n</code></pre> <p>This requires Go 1.14.</p>"},{"location":"pages/input_types/helm/#helm-subcharts","title":"Helm subcharts","text":"<p>There is an external dependency manager of type <code>helm</code> which enables you to specify helm charts to download, including subcharts.</p>"},{"location":"pages/input_types/introduction/","title":"Introduction","text":"<p>Note: make sure to read up on inventory before moving on.</p>"},{"location":"pages/input_types/introduction/#phases-of-the-compile-command","title":"Phases of the compile command","text":"<p>Now that we have a basic understanding of Kapitan <code>inventory</code>, we can talk about the <code>kapitan compile</code> command.</p> <p>The command has five distinct <code>phases</code>:</p> <pre><code>graph LR\n  classDef pink fill:#f9f,stroke:#333,stroke-width:4px,color:#000,font-weight: bold;\n  classDef blue fill:#00FFFF,stroke:#333,stroke-width:4px,color:#000,font-weight: bold;\n  INVENTORY[\"Inventory\"]:::pink\n\n  COMPILE[\"Compile\"]:::pink\n  FINISH[\"Finish\"]:::pink\n  COPY[\"Copy\"]:::pink\n\n\n  subgraph \"fetch\"\n    F{\"fetch?\"}\n    FETCH[\"fetch dependencies\"]\n  end \n\n  subgraph \"validate\"\n    V{\"validate?\"}\n    VALIDATE[\"Validate\"]\n  end\n\n  subgraph \"reveal\"\n    REVEAL[\"Reveal\"]\n    R{\"reveal?\"}\n  end\n\n  INVENTORY --&gt; F\n  F --&gt; |yes| FETCH\n  FETCH --&gt; COMPILE\n  F ==&gt; |no| COMPILE\n  COMPILE ==&gt; R\n  R ==&gt; |no| COPY\n  R --&gt; |yes| REVEAL\n  REVEAL --&gt; COPY\n  COPY --&gt; V\n  V --&gt; |yes| VALIDATE\n  V ==&gt; |no| FINISH\n  VALIDATE --&gt; FINISH\n\n</code></pre> Step Flag Description Configuration Inventory Kapitan uses reclass to render a final version of the inventory. Fetch <code>--fetch</code> Kapitan fetches external dependencies <code>parameters.kapitan.dependencies</code> Compile Kapitan compiles the input types for each target <code>parameters.kapitan.compile</code> Reveal <code>--reveal</code> Kapitan reveals the secrets directly in the compiled output <code>parameters.kapitan.secrets</code> Copy Kapitan moves the output files from the tmp directory to <code>/compiled</code> Validate <code>--validate</code> Kapitan validates the schema of compiled output. <code>parameters.kapitan.validate</code> Finish Kapitan has completed all tasks"},{"location":"pages/input_types/introduction/#supported-input-types","title":"Supported input types","text":"<p>Input types can be specified in the inventory under <code>kapitan.compile</code> in the following format:</p> jinja2jsonnetkadethelmcopy <pre><code>parameters:\n  kapitan:\n    compile:\n    - output_path: &lt;output_path_in_target_dir&gt;\n      input_type: jinja2 \n      input_params: # (1)! \n      input_paths:\n        - directory/\n        - file\n        - globbed/path/*\n</code></pre> <ol> <li>a dict passed to the template</li> </ol> <p>Please see Jinja</p> <pre><code>parameters:\n  kapitan:\n    compile:\n    - output_path: &lt;output_path_in_target_dir&gt;\n      input_type: jsonnet \n      prune: false # (1)! \n      input_paths:\n        - directory/\n        - file\n        - globbed/path/*\n      output_type: [`yaml` | `json`]\n</code></pre> <ol> <li>(Default: global --prune)</li> </ol> <pre><code>parameters:\n  kapitan:\n    compile:\n    - output_path: &lt;output_path_in_target_dir&gt;\n      input_type: kadet \n      prune: false # (1)! \n      input_paths:\n        - directory/\n        - file\n        - globbed/path/*\n      output_type: [`yaml` | `json`]\n</code></pre> <ol> <li>(Default: global --prune)</li> </ol> <p>Please see Kadet</p> <pre><code>parameters:\n  kapitan:\n    compile:\n    - output_path: &lt;output_path_in_target_dir&gt;\n      input_type: helm \n      prune: false # (1)! \n      input_paths:\n        - directory/\n        - file\n        - globbed/path/*\n      output_type: &lt;output_type_specific_to_input_type&gt;\n</code></pre> <ol> <li>(Default: global --prune)</li> </ol> <pre><code>parameters:\n  kapitan:\n    compile:\n    - output_path: &lt;output_path_in_target_dir&gt;\n      input_type: copy \n      prune: false # (1)! \n      input_paths:\n        - directory/\n        - file\n        - globbed/path/*\n      output_type: &lt;output_type_specific_to_input_type&gt;\n</code></pre> <ol> <li>(Default: global --prune)</li> </ol>"},{"location":"pages/input_types/jinja/","title":"Input Type | Jinja2","text":"<p>This input type is probably the most simple input type to use: it is very versatile and is commonly used to create scripts and documentation files.</p> <p>It renders jinja2 templates.</p>"},{"location":"pages/input_types/jinja/#example-configuration","title":"Example configuration","text":"<p>Here's some configuration from the nginx example</p> <p>examples/kubernetes/inventory/classes/component/nginx-common.yml</p> <pre><code>  templates: #(1)!\n    - docs/nginx/README.md\n    - components/nginx-deploy.sh\n\n  kapitan:\n    compile:\n      - output_path: . #(2)!\n        input_type: jinja2\n        input_paths: ${templates} #(3)!\n</code></pre> <ol> <li>We define a list with all the templates we want to compile with this input type</li> <li>Then input type will render the files a the root of the target compiled folder e.g. <code>compiled/${target_name}</code></li> <li>We pass the list as <code>input_paths</code></li> </ol> <p>Notice how make use of variable interpolation to use the convenience of a list to add all the files we want to compile.   You can now simply add to that list from any other place in the inventory that calls that class.</p> <ul> <li><code>input_paths</code> can either be a file, or a directory: in case of a directory, all the templates in the directory will be rendered.</li> <li><code>input_params</code> (optional) can be used to pass extra parameters, helpful when needing to use a similar template for multiple components in the same target.</li> </ul>"},{"location":"pages/input_types/jinja/#documentation","title":"Documentation","text":"<p>We usually store documentation templates under the <code>templates/docs</code> directory.</p> <p>examples/kubernetes/docs/nginx/README.md</p> <pre><code>{% set i = inventory.parameters %}\n\n# Welcome to the README!\n\nTarget *{{ i.target_name }}* is running:\n\n* {{ i.nginx.replicas }} replicas of *nginx* running nginx image {{ i.nginx.image }}\n* on cluster {{ i.cluster.name }}\n</code></pre> <p>Compiled result</p> <pre><code># Welcome to the README!\n\nTarget *minikube-nginx-jsonnet* is running:\n\n* 1 replicas of *nginx* running nginx image nginx:1:15.8\n* on cluster minikube\n</code></pre>"},{"location":"pages/input_types/jinja/#scripts","title":"Scripts","text":"<p>When we use Jinja to render scripts, we tend to call them \"canned scripts\" to indicate that these scripts have everything needed to run without extra parameters.</p> <p>We usually store script templates under the <code>templates/scripts</code> directory.</p> <p>examples/kubernetes/components/nginx-deploy.sh</p> <pre><code>#!/bin/bash -e\nDIR=$(dirname ${BASH_SOURCE[0]})\n{% set i = inventory.parameters %} #(1)!\n\nKUBECTL=\"kubectl -n {{i.namespace}}\" #(2)!\n\n# Create namespace before anything else\n${KUBECTL} apply -f ${DIR}/pre-deploy/namespace.yml\n\nfor SECTION in manifests\ndo\n  echo \"## run kubectl apply for ${SECTION}\"\n  ${KUBECTL} apply -f ${DIR}/${SECTION}/ | column -t\ndone\n</code></pre> <ol> <li>We import the <code>inventory</code> as a Jinja variable</li> <li>We use to set the <code>namespace</code> explicitly</li> </ol> <p>Compiled result</p> <pre><code>#!/bin/bash -e\nDIR=$(dirname ${BASH_SOURCE[0]})\n #(1)!\n\nKUBECTL=\"kubectl -n minikube-nginx-jsonnet\" #(2)!\n\n# Create namespace before anything else\n${KUBECTL} apply -f ${DIR}/pre-deploy/namespace.yml\n\nfor SECTION in manifests\ndo\n  echo \"## run kubectl apply for ${SECTION}\"\n  ${KUBECTL} apply -f ${DIR}/${SECTION}/ | column -t\ndone\n</code></pre> <ol> <li>The script is now a \"canned script\" and ready to be used for this specif target. </li> <li>You can see that the namespace has been replaced with the target's one.</li> </ol>"},{"location":"pages/input_types/jinja/#accessing-the-inventory","title":"Accessing the inventory","text":"<p>Templates will be provided at runtime with 3 variables:</p> <ul> <li><code>inventory</code>: To access the inventory for that specific target.</li> <li><code>inventory_global</code>: To access the inventory of all targets.</li> <li><code>input_params</code>: To access the optional dictionary provided to the input type.</li> </ul> <p>Use of <code>inventory_global</code></p> <p><code>inventory_global</code> can be used to generate a \"global\" <code>README.md</code> that contains a link to all generated targets. <pre><code>| *Target*                                                               |\n|------------------------------------------------------------------------|\n{% for target in inventory_global | sort() %}\n{% set p = inventory_global[target].parameters %}\n|[{{target}}](../{{target}}/docs/README.md)                              |\n{% endfor %}\n</code></pre></p> <p>Compiled result</p> <pre><code>| *Target*                                                               |\n|------------------------------------------------------------------------|\n| [argocd](../argocd/docs/README.md)                                     |\n| [dev-sockshop](../dev-sockshop/docs/README.md)                         |\n| [echo-server](../echo-server/docs/README.md)                           |\n| [examples](../examples/docs/README.md)                                 |\n| [gke-pvm-killer](../gke-pvm-killer/docs/README.md)                     |\n| [global](../global/docs/README.md)                                     |\n| [guestbook-argocd](../guestbook-argocd/docs/README.md)                 |\n| [kapicorp-demo-march](../kapicorp-demo-march/docs/README.md)           |\n| [kapicorp-project-123](../kapicorp-project-123/docs/README.md)         |\n| [kapicorp-terraform-admin](../kapicorp-terraform-admin/docs/README.md) |\n| [mysql](../mysql/docs/README.md)                                       |\n| [postgres-proxy](../postgres-proxy/docs/README.md)                     |\n| [pritunl](../pritunl/docs/README.md)                                   |\n| [prod-sockshop](../prod-sockshop/docs/README.md)                       |\n| [sock-shop](../sock-shop/docs/README.md)                               |\n| [tesoro](../tesoro/docs/README.md)                                     |\n| [tutorial](../tutorial/docs/README.md)                                 |\n| [vault](../vault/docs/README.md)                                       |\n</code></pre>"},{"location":"pages/input_types/jinja/#jinja2-custom-filters","title":"Jinja2 custom filters","text":"<p>We support the following custom filters for use in Jinja2 templates:</p> EncodingTimeRegexp<code>fileglob</code><code>bool</code><code>ternary</code><code>shuffle</code><code>reveal_maybe</code> <code>sha256</code><code>yaml</code><code>toml</code><code>b64encode</code><code>b64decode</code> <p>SHA256 hashing of text</p> <p><code>{{ text | sha256 }}</code></p> <p>Dump text as YAML</p> <p><code>{{ text | yaml }}</code></p> <p>Dump text as TOML</p> <p><code>{{ text | toml }}</code></p> <p>base64 encode text</p> <p><code>{{ text | b64encode }}</code></p> <p>base64 decode text</p> <p><code>{{ text | b64decode }}</code></p> <code>to_datetime</code><code>strftime</code> <p>return datetime object for string</p> <p><code>{{ \"2019-03-07 13:37:00\" | to_datetime }}</code></p> <p>return current date string for format</p> <p><code>{{ \"%a, %d %b %Y %H:%M\" | strftime }}</code></p> <code>regex_replace</code><code>regex_escape</code><code>regex_search</code><code>regex_findall</code> <p>perform a <code>re.sub</code> returning a string</p> <p><code>{{ hello world | regex_replace(pattern=\"world\", replacement=\"kapitan\")}}</code></p> <p>escape all regular expressions special characters from string</p> <p><code>{{ \"+s[a-z].*\" | regex_escape}}</code></p> <p>perform <code>re.search</code> and return the list of matches or a backref</p> <p><code>{{  hello world | regex_search(\"world.*\")}}</code></p> <p>perform <code>re.findall</code> and return the list of matches as array</p> <p><code>{{ hello world | regex_findall(\"world.*\")}}</code> </p> <p>return list of matched regular files for glob</p> <p><code>{{ ./path/file* | fileglob }}</code></p> <p>return the bool for value</p> <p><code>{{ yes | bool }}</code></p> <p><code>value ? true_val : false_val</code></p> <p><code>{{ condition | ternary(\"yes\", \"no\")}}</code></p> <p>randomly shuffle elements of a list</p> <p><code>{{ [1, 2, 3, 4, 5] | shuffle }}</code></p> <p>reveal <code>ref/secret</code> tag only if <code>compile --reveal</code> flag is set</p> <p><code>{{ \"?{base64:my_ref}\" | reveal_maybe}}</code></p> <p>Tip</p> <p>You can also provide path to your custom filter modules in CLI. By default, you can put your filters in <code>lib/jinja2_filters.py</code> and they will automatically get loaded.</p>"},{"location":"pages/input_types/jsonnet/","title":"Input Type | Jsonnet","text":"<p>Jsonnet is a superset of json format that includes features such as conditionals, variables and imports. Refer to jsonnet docs to understand how it works.</p> <p>Note: unlike jinja2 templates, one jsonnet template can output multiple files (one per object declared in the file).</p>"},{"location":"pages/input_types/jsonnet/#accessing-the-inventory","title":"Accessing the inventory","text":"<p>Typical jsonnet files would start as follows:</p> <pre><code>local kap = import \"lib/kapitan.libjsonnet\"; #(1)!\nlocal inv = kap.inventory(); #(2)!\nlocal p = inv.parameters; #(3)!\n\n{\n    \"data_java_opts\": p.elasticsearch.roles.data.java_opts, #(4)!\n}\n</code></pre> <ol> <li>Import the Kapitan inventory library.</li> <li>Assign the content of the full inventory for this specific target to the <code>inv</code> variable.</li> <li>Assign the content of the <code>inventory.parameters</code> to a variable <code>p</code> for convenience.</li> <li>Use the <code>p</code> variable fo access a specific intentory value</li> </ol> <p>Note: The dictionary keys of the jsonnet object are used as filenames for the generated output files. If your jsonnet is not a dictionary, but is a valid json(net) object, then the output filename will be the same as the input filename. E.g. <code>'my_string'</code> is inside <code>templates/input_file.jsonnet</code> so the generated output file will be named <code>input_file.json</code> for example and will contain <code>\"my_string\"</code>.</p>"},{"location":"pages/input_types/jsonnet/#jinja2-templating","title":"Jinja2 templating","text":"<p>Kapitan allows you to compile a Jinja template from within Jsonnet:</p> <pre><code>local kap = import \"lib/kapitan.libjsonnet\";\n\n{\n    \"jon_snow\": kap.jinja2_template(\"templates/got.j2\", { is_dead: false }),\n}\n</code></pre>"},{"location":"pages/input_types/jsonnet/#callback-functions","title":"Callback functions","text":"<p>In addition, importing <code>kapitan.libjsonnet</code> makes available the following native_callback functions gluing reclass to jsonnet (amongst others):</p> inventoryjinja2_templateyamlfile I/Osha256_stringgzip_b64jsonschema <p>returns a dictionary with the inventory for target</p> <p>renders the jinja2 file with context specified</p> yaml_loadyaml_load_streamyaml_dumpyaml_dump_stream <p>returns a json string of the specified yaml file</p> <p>returns a list of json strings of the specified yaml file</p> <p>returns a string yaml from a json string</p> <p>returns a string yaml stream from a json string</p> file_readfile_existsdir_files_listdir_files_read <p>reads the file specified</p> <p>returns informative object if a file exists</p> <p>returns a list of file in a dir</p> <p>returns an object with keys - file_name and values - file contents</p> <p>returns sha256 of string</p> <p>returns base64 encoded gzip of obj</p> <p>validates obj with schema, returns object with 'valid' and 'reason' keys</p>"},{"location":"pages/input_types/jsonnet/#jsonschema-validation","title":"Jsonschema validation","text":"<p>Given the follow example inventory:</p> <pre><code>mysql:\n  storage: 10G\n  storage_class: standard\n  image: mysql:latest\n</code></pre> <p>The yaml inventory structure can be validated with the new <code>jsonschema()</code> function:</p> <pre><code>local schema = {\n    type: \"object\",\n    properties: {\n        storage: { type: \"string\", pattern: \"^[0-9]+[MGT]{1}$\"},\n        image: { type: \"string\" },\n    }\n};\n// run jsonschema validation\nlocal validation = kap.jsonschema(inv.parameters.mysql, schema);\n// assert valid, otherwise error with validation.reason\nassert validation.valid: validation.reason;\n</code></pre> <p>If <code>validation.valid</code> is not true, it will then fail compilation and display <code>validation.reason</code>.</p> <p>Fails validation because <code>storage</code> has an invalid pattern (<code>10Z</code>)</p> <pre><code>Jsonnet error: failed to compile /code/components/mysql/main.jsonnet:\nRUNTIME ERROR: '10Z' does not match '^[0-9]+[MGT]{1}$'\n\nFailed validating 'pattern' in schema['properties']['storage']:\n    {'pattern': '^[0-9]+[MGT]{1}$', 'type': 'string'}\n\nOn instance['storage']:\n    '10Z'\n\n/code/mysql/main.jsonnet:(19:1)-(43:2)\n\nCompile error: failed to compile target: minikube-mysql\n</code></pre>"},{"location":"pages/input_types/kadet/","title":"Input Type | Kadet","text":"<p>Kadet is an extensible input type for Kapitan that enables you to generate templates using Python. </p> <p>The key benefit being the ability to utilize familiar programing principles while having access to Kapitan's powerful inventory system.</p> <p>A library that defines resources as classes using the Base Object class is required. These can then be utilized within components to render output.</p> <p>The following functions are provided by the class <code>BaseObj()</code>.</p> <p>Method definitions:</p> <ul> <li><code>new()</code>: Provides parameter checking capabilities</li> <li><code>body()</code>: Enables in-depth parameter configuration</li> </ul> <p>Method functions:</p> <ul> <li><code>root()</code>: Defines values that will be compiled into the output</li> <li><code>need()</code>: Ability to check &amp; define input parameters</li> <li><code>update_root()</code>: Updates the template file associated with the class</li> </ul> <p>A class can be a resource such as a Kubernetes Deployment as shown here:</p> <pre><code>class Deployment(BaseObj): # (1)!\n    def new(self): # (2)!\n        self.need(\"name\", \"name string needed\")\n        self.need(\"labels\", \"labels dict needed\")\n        self.need(\"containers\", \"containers dict needed\")\n        self.update_root(\"lib/kubelib/deployment.yml\")\n\n    def body(self): # (3)!\n        self.root.metadata.name = self.kwargs.name # (4)!\n        self.root.metadata.namespace = inv.parameters.target_name\n        self.root.spec.template.metadata.labels = self.kwargs.labels\n        self.root.spec.template.spec.containers = self.kwargs.containers\n</code></pre> <ol> <li>The deployment is an <code>BaseObj()</code> which has two main functions. </li> <li><code>new(self)</code> is used to perform parameter validation &amp; template compilation</li> <li><code>body(self)</code> is utilized to set those parameters to be rendered. </li> <li><code>self.root.metadata.name</code> is a direct reference to a key in the corresponding yaml.</li> </ol> <p>Kadet supports importing libraries as you would normally do with Python. These libraries can then be used by the components to generate the required output.</p> <pre><code>...\nkubelib = kadet.load_from_search_paths(\"kubelib\") #(1)!\n...\nname = \"nginx\"\nlabels = kadet.BaseObj.from_dict({\"app\": name})\nnginx_container = kubelib.Container( #(2)!\n    name=name, image=inv.parameters.nginx.image, ports=[{\"containerPort\": 80}]\n)\n...\ndef main():\n    output = kadet.BaseObj() #(3)!\n    output.root.nginx_deployment = kubelib.Deployment(name=name, labels=labels, containers=[nginx_container]) #(4)!\n    output.root.nginx_service = kubelib.Service( #(5)!\n        name=name, labels=labels, ports=[svc_port], selector=svc_selector\n    )\n    return output #(6)!\n</code></pre> <ol> <li>We import a library called <code>kubelib</code> using <code>load_from_search_paths()</code></li> <li>We use <code>kubelib</code> to create a <code>Container</code></li> <li>We create an output of type <code>BaseObj</code> and we will be updating the <code>root</code> element of this output.</li> <li>We use <code>kubelib</code> to create a <code>Deployment</code> kind. The Deployment makes use of the Container created.</li> <li>We use <code>kubelib</code> to create a <code>Service</code> kind.</li> <li>We return the object. Kapitan will render everything under <code>output.root</code></li> </ol> <p>Kadet uses a library called addict to organise the parameters inline with the yaml templates. As shown above we create a <code>BaseObject()</code> named output. We update the root of this output with the data structure returned from kubelib. This output is what is then returned to kapitan to be compiled into the desired output type.</p> <p>For a deeper understanding please refer to github.com/kapicorp/kadet</p> <p>Supported output types:</p> <ul> <li><code>yaml</code> (default)</li> <li><code>json</code></li> </ul>"},{"location":"pages/input_types/remove/","title":"Remove","text":"<p>This input type simply removes files or directories. This can be helpful if you can't control particular files generated during other compile inputs.</p> <p>For example, to remove a file named <code>copy_target</code>, specify an entry to <code>input_paths</code>, <code>compiled/${kapitan:vars:target}/copy_target</code>.</p> <pre><code>parameters:\n  target_name: removal\n  kapitan:\n    vars:\n      target: ${target_name}\n    compile:\n      - input_type: copy\n        input_paths:\n          - copy_target\n        output_path: .\n      # test removal of a file\n      - input_type: remove\n        input_paths:\n          - compiled/${kapitan:vars:target}/copy_target\n        output_path: .\n</code></pre> <p>As a reminder, each input block within the compile array is run sequentially for a target in Kapitan. If we reversed the order of the inputs above like so:</p> <pre><code>parameters:\n  target_name: removal\n  kapitan:\n    vars:\n      target: ${target_name}\n    compile:\n      - input_type: remove\n        input_paths:\n          - compiled/${kapitan:vars:target}/copy_target\n        output_path: .\n      - input_type: copy\n        input_paths:\n          - copy_target\n        output_path: .\n</code></pre> <p>The first input block would throw an error because the copy input command hasn't run yet to produce the file being removed by the remove input block.</p> <p>Supported output types: N/A (no need to specify <code>output_type</code>)</p>"},{"location":"pages/inventory/advanced/","title":"Advanced Inventory Features","text":""},{"location":"pages/inventory/advanced/#target-labels","title":"Target labels","text":"<p>Kapitan allows you to define labels in your inventory, which can then be used to group together targets with similar labels.</p> <p>For instance you could define the following:</p> <p>Defines a class to add the <code>customer</code> label to selected targets</p> <p><code>inventory/classes/type/customer_project.yml</code></p> <pre><code>parameters:\n  customer_name: ${target_name} # Defaults to the target_name\n  kapitan:\n    labels:\n      customer: ${customer_name}\n</code></pre> <p>Apply the class to the target for customer <code>acme</code></p> <p><code>inventory/targets/customers/acme.yml</code></p> <pre><code>classes:\n...\n- type.customer_project\n\nparameters:\n...\n</code></pre> <p>You can now selectively compile targets for customer <code>acme</code> using the following (see see Labels for more details )</p> <pre><code>kapitan compile -l customer=acme\nCompiled acme (0.06s)\nCompiled acme-documentation (0.09s)\n</code></pre>"},{"location":"pages/inventory/classes/","title":"Classes","text":""},{"location":"pages/inventory/classes/#usage","title":"Usage","text":"<p>The next thing you want to learn about the inventory are classes. A class is a yaml file containing a fragment of yaml that we want to import and merge into the inventory.</p> <p>Classes are fragments of yaml: feature sets, commonalities between targets. Classes let you compose your Inventory from smaller bits, eliminating duplication and exposing all important parameters from a single, logically organised place. As the Inventory lets you reference other parameters in the hierarchy, classes become places where you can define something that will then get referenced from another section of the inventory, allowing for composition.</p> <p>Classes are organised under the <code>inventory/classes</code> directory substructure.  They are organised hierarchically in subfolders, and the way they can be imported into a target or other classes depends on their location relative to the <code>inventory/classes</code> directory.</p>"},{"location":"pages/inventory/classes/#importing-classes","title":"Importing classes","text":"<p>To import a class from within another file of the Inventory, you can follow these instructions:</p> <ul> <li>take the file path relative to the <code>inventory/classes/</code> directory</li> <li>remove the <code>.yml</code> file extension</li> <li>replace <code>/</code> with <code>.</code></li> </ul> <p>For example, this will import the class <code>inventory/classes/applications/sock-shop.yaml</code></p> <pre><code>classes:\n- applications.sock-shop\n</code></pre>"},{"location":"pages/inventory/classes/#definition","title":"Definition","text":"<p>Let's take a look at the <code>common</code> class which appears in the example above:</p> <p>As explained, because the <code>common.yaml</code> is directly under the <code>inventory/classes</code> subdirectory, it can be imported directly into a target with:</p> <pre><code>classes:\n- common\n</code></pre> <p>If we open the file, we find another familiar yaml fragment.</p> <p><code>inventory/classes/common.yml</code></p> <pre><code>classes:\n- kapitan.common\n\nparameters:\n  namespace: ${target_name}\n  target_name: ${_reclass_:name:short}\n</code></pre> <p>Notice that this class includes an import definition for another class, <code>kapitan.common</code>. We've already learned this means that kapitan will import a file on disk called <code>inventory/classes/kapitan/common.yml</code></p> <p>You can also see that in the <code>parameters</code> section we now encounter a new syntax which unlocks another powerful inventory feature: parameters interpolation!</p>"},{"location":"pages/inventory/introduction/","title":"Introduction","text":""},{"location":"pages/inventory/introduction/#overview","title":"Overview","text":"<p>The Inventory is a core component of Kapitan: this section aims to explain how it works and how to best take advantage of it.</p> <p>The Inventory is a hierarchical <code>YAML</code> based structure which you use to capture anything that you want to make available to Kapitan, so that it can be passed on to its templating engines.</p> <p>The first concept to learn about the Inventory is the target. A target is a file, found under the <code>inventory/targets</code> substructure, that tells Kapitan what you want to compile. It will usually map to something you want to do with Kapitan. </p> <p>For instance, you might want to define a target for each environment that you want to deploy using Kapitan. </p> <p>The Inventory lets you also define and reuse common configurations through YAML files that are referred to as classes: by listing classes into target, their content gets merged together and allows you to compose complex configurations without repetitions.</p> <p>By combining target and classes, the Inventory becomes the SSOT for your whole configuration, and learning how to use it will unleash the real power of Kapitan.</p> <p>Info</p> <p>The Kapitan Inventory is based on an open source project called reclass and you can find the full documentation on our Github clone. However we discourage you to look directly at the reclass documentation before you learn more about Kapitan, because Kapitan uses a fork of reclass and greatly simplifies the reclass experience.</p> <p>Info</p> <p>Kapitan allows users to switch the inventory backend to reclass-rs. You can switch the backend to reclass-rs by passing <code>--inventory-backend=reclass-rs</code> on the command line. Alternatively, you can define the backend in the .kapitan config file.</p> <p>See the reclass-rs inventory backend documentation for more details.</p> <p>Note</p> <p>Kapitan enforces very little structure for the Inventory, so that you can adapt it to your specific needs: this might be overwhelming at the beginning: don\u2019t worry, we will explain best practice and give guidelines soon.</p> <p>By default, Kapitan will search for its Inventory under <code>inventory/classes</code> and <code>inventory/targets</code>.</p> <pre><code>inventory/\n\u251c\u2500\u2500 classes\n\u2502   \u251c\u2500\u2500 applications\n\u2502   \u251c\u2500\u2500 components\n\u2502   \u251c\u2500\u2500 features\n\u2502   \u251c\u2500\u2500 kapitan\n\u2502   \u251c\u2500\u2500 projects\n\u2502   \u2514\u2500\u2500 terraform\n\u2514\u2500\u2500 targets\n    \u251c\u2500\u2500 examples\n    \u251c\u2500\u2500 kapicorp\n    \u2514\u2500\u2500 terraform\n</code></pre>"},{"location":"pages/inventory/parameters_interpolation/","title":"Parameters Interpolation","text":"<p>Note</p> <p>as a shorthand, when we encounter deep yaml structures like the following:</p> <pre><code>parameters:\n  components:\n    nginx:\n      image: nginx:latest\n</code></pre> <p>Usually when we want to talk about the <code>image</code> subkey, we normally use either of the following: </p> <ul> <li><code>parameters.components.nginx.image</code></li> <li><code>components.nginx.image</code></li> </ul> <p>However, when used in parameter expansion, remember to:</p> <ul> <li>replace the <code>.</code> with <code>:</code> </li> <li>omit the <code>parameters</code> initial key which is implied</li> <li>wrap it into the <code>${}</code> variable interpolation syntax</li> </ul> <p>The correct way to reference <code>parameters.nginx.image</code> then becomes <code>${components:nginx:image}</code>. </p> <p>The Inventory allows you to refer to other values defined elsewhere in the structure, using parameter interpolation.</p> <p>Given the example:</p> <pre><code>parameters:\n  cluster:\n    location: europe\n\n  application:\n    location: ${cluster:location}\n\n  namespace: ${target_name}\n  target_name: dev\n</code></pre> <p>Here we tell Kapitan that:</p> <ul> <li><code>namespace</code> should take the same value defined in <code>target_name</code></li> <li><code>target_name</code> should take the literal string <code>dev</code></li> <li><code>application.location</code> should take the same value as defined in <code>cluster.location</code></li> </ul> <p>It is important to notice that the inventory can refer to values defined in other classes, as long as they are imported by the target. So for instance with the following example</p> <pre><code>classes:\n  - project.production\n\n  parameters:\n    application:\n      location: ${cluster.location}\n</code></pre> <p>Here in this case <code>application.location</code> refers to a value <code>location</code> which has been defined elsewhere, perhaps (but not necessarily) in the <code>project.production</code> class.</p> <p>Also notice that the class name (<code>project.production</code>) is not in any ways influencing the name or the structed of the yaml it imports into the file</p>"},{"location":"pages/inventory/reclass-rs/","title":"The reclass-rs inventory backend","text":""},{"location":"pages/inventory/reclass-rs/#overview","title":"Overview","text":"<p>Reclass-rs is a reimplementation of Kapitan's Reclass fork in Rust. Please note that the Rust implementation doesn't support all the features of Kapitan's Reclass fork yet.</p> <p>However, reclass-rs improves rendering time for the inventory significantly, especially if you're making heavy use of parameter references in class includes. If some of the Reclass features or options that you're using are missing in reclass-rs, don't hesitate to open an issue in the reclass-rs project.</p>"},{"location":"pages/inventory/reclass-rs/#installation","title":"Installation","text":"<p>The <code>reclass-rs</code> Python package is an optional dependency of Kapitan. You can install it as follows:</p> <pre><code>pip install kapitan[reclass-rs]\n</code></pre>"},{"location":"pages/inventory/reclass-rs/#usage","title":"Usage","text":"<p>To use the reclass-rs inventory backend, you need to pass <code>--inventory-backend=reclass-rs</code> on the command line. If you want to permanently switch to the reclass-rs inventory backend, you can select the inventory backend in the .kapitan config file:</p> <pre><code>global:\n  inventory-backend: reclass-rs\n</code></pre>"},{"location":"pages/inventory/reclass-rs/#performance-comparison","title":"Performance comparison","text":"<p>For the performance comparison, a real Kapitan inventory which makes heavy use of parameter interpolation in class includes was rendered with both Reclass and reclass-rs. The example inventory that was used for the performance comparison contains 325 classes and 56 targets. The example inventory renders to a total of 25MB of YAML.</p>"},{"location":"pages/inventory/reclass-rs/#reclass","title":"Reclass","text":"<pre><code>$ time kapitan inventory -v --inventory-backend=reclass &gt; inv.yml\n[ ... some output omitted ... ]\nkapitan.resources DEBUG    Using reclass as inventory backend\nkapitan.inventory.inv_reclass DEBUG    Inventory reclass: No config file found. Using reclass inventory config defaults\nkapitan.inventory.inv_reclass DEBUG    Inventory rendering with reclass took 0:01:06.037057\n\nreal    1m23.840s\nuser    1m23.520s\nsys     0m0.287s\n</code></pre> <p>Reclass takes 1 minute and 6 seconds to render the example inventory. The rest of the runtime (roughly 18 seconds) is spent in writing the resulting 25MB of YAML to the output file.</p>"},{"location":"pages/inventory/reclass-rs/#reclass-rs","title":"reclass-rs","text":"<pre><code>$ time kapitan inventory -v --inventory-backend=reclass-rs &gt; inv-rs.yml\n[ ... some output omitted ... ]\nkapitan.resources DEBUG    Using reclass-rs as inventory backend\nkapitan.inventory.inv_reclass DEBUG    Inventory reclass: No config file found. Using reclass inventory config defaults\nreclass-config.yml entry 'storage_type=yaml_fs' not implemented yet, ignoring...\nreclass-config.yml entry 'inventory_base_uri=./inventory' not implemented yet, ignoring...\nreclass-config.yml entry 'allow_none_override=true' not implemented yet, ignoring...\nkapitan.inventory.inv_reclass_rs DEBUG    Inventory rendering with reclass-rs took 0:00:01.717107\n\nreal    0m19.921s\nuser    0m35.586s\nsys     0m1.066s\n</code></pre> <p>reclass-rs takes 1.7 seconds to render the example inventory. The rest of the runtime (roughly 18 seconds) is spent in writing the resulting 25MB of YAML to the output file.</p>"},{"location":"pages/inventory/targets/","title":"Targets","text":""},{"location":"pages/inventory/targets/#usage","title":"Usage","text":"<p>A target is a file that lives under the <code>inventory/targets</code> subdirectory, and that tells Kapitan what you want it to do for you.</p> <p>Kapitan will recognise all YAML files in the <code>inventory/targets</code> subtree as targets.</p> <p>Note</p> <p>Only use <code>.yml</code> as extension for Inventory files. <code>.yaml</code> will not be recognised as a valid Inventory file.</p> <p>What you do with a target is largely up to you and your setup. Common examples:</p> <ul> <li>clusters: Map each target to a cluster, capturing all configurations needed for a given cluster. For instance: <code>targets/clusters/production-cluster1.yml</code></li> <li>applications: When using Kapitan to manage Kubernetes applications, you might define a target for everything that you would normally deploy in a single namespace, including all its resources, scripts, secrets and documentation. For instance: <code>targets/mysql.yml</code></li> <li>environments: You might have want to define a different target for each environment you have, like <code>dev.yml</code>, <code>test.yml</code> and <code>prod.yml</code></li> <li>cloud projects: When working with Terraform, it may be convenient to group target by cloud project. For instance: <code>targets/gcp/projects/engineering-prod.yml</code>.</li> <li>single tenancy: When deploying a single-tenancy application, you might combine the approaches above, and have a target <code>acme.yml</code> that is used to define both Terraform and Kubernetes resources for a given tenant, perhaps also with some ArgoCD or Spinnaker pipelines to go with it.</li> </ul> <p>Example</p> <p>If you have configured your kapitan repository like in Quick Start instructions, you can run the commands we give during the course of this documentation.</p> <p><code>kapitan compile</code></p> <pre><code>Compiled gke-pvm-killer (0.09s)\nCompiled vault (0.18s)\nCompiled pritunl (0.17s)\nCompiled mysql (0.07s)\nCompiled examples (0.25s)\nCompiled postgres-proxy (0.06s)\nCompiled echo-server (0.08s)\nCompiled global (0.05s)\nCompiled tutorial (0.09s)\nCompiled guestbook-argocd (0.08s)\nCompiled sock-shop (0.30s)\nCompiled kapicorp-demo-march (0.04s)\nCompiled kapicorp-project-123 (0.03s)\nCompiled kapicorp-terraform-admin (0.08s)\nCompiled tesoro (0.09s)\nCompiled prod-sockshop (0.34s)\nCompiled dev-sockshop (0.41s)\nCompiled argocd (2.53s)\n</code></pre> <p>When you run <code>kapitan compile</code>, you instruct Kapitan to generate for each given target a directory under <code>compiled</code> with the same name. Under this directory you will find all the files that have been generated by Kapitan for that target.</p> <p><code>tree compiled/mysql/</code></p> <pre><code>compiled/mysql/\n\u251c\u2500\u2500 argocd\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 mysql-readme.md\n\u2502   \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 manifests\n\u2502   \u251c\u2500\u2500 mysql-bundle.yml\n\u2502   \u251c\u2500\u2500 mysql-config.yml\n\u2502   \u251c\u2500\u2500 mysql-namespace.yml\n\u2502   \u2514\u2500\u2500 mysql-secret.yml\n\u251c\u2500\u2500 pre-deploy\n\u251c\u2500\u2500 rabbitmq\n\u251c\u2500\u2500 scripts\n\u2514\u2500\u2500 terraform\n\n7 directories, 6 files\n</code></pre>"},{"location":"pages/inventory/targets/#definition","title":"Definition","text":"<p>A typical target might look like this:</p> <p><code>inventory/targets/acme/dev.yaml</code></p> <pre><code>classes:\n  - common\n  - components.acme.frontend\n  - components.acme.backend\n\nparameters:\n  target_name: dev\n</code></pre> <p>Note that it is made of 2 sections:</p> <ul> <li><code>classes</code> is a list of class files you will want to import.</li> <li><code>parameters</code> allows for local override of what is unique to this target. </li> </ul> <p>Info</p> <p>the <code>kapitan</code> key under the root <code>parameters</code> is reserved for kapitan usage. Some examples:</p> <pre><code>parameters:\n  kapitan:\n    compile:      # input types configuration section\n    dependencies: # dependencies configuration section to download resources\n    secrets:      # secret encryption/decryption configuration section\n    validate:     # items which indicate which compiled output to validate\n    vars:         # which are also passed down to input types as context\n</code></pre>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#community","title":"community","text":"<ul> <li>Proposals</li> <li>Kapitan Code</li> <li>Documentation</li> <li>Sponsor Us</li> </ul>"},{"location":"tags/#kadet","title":"kadet","text":"<ul> <li>Kadet</li> </ul>"},{"location":"tags/#kubernetes","title":"kubernetes","text":"<ul> <li>Kadet</li> </ul>"}]}